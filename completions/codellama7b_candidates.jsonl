{"task_id": "codeeval-0", "solution": "from functools import singledispatch\n@singledispatch\ndef process_argument(arg):\n    return None\n\n@process_argument.register(int)\ndef _(arg):\n    return abs(arg)\n\n@process_argument.register(str)\ndef _(arg):\n    return len(arg)\n\n@process_argument.register(float)\ndef _(arg):\n    return arg ** 2"}
{"task_id": "codeeval-1", "solution": "def cartesian_product(*iterables):\n    # Base case:\n    if len(iterables) == 1:\n        for item in iterables[0]:\n            yield (item,)\n    # Induction step:\n    else:\n        for item in iterables[0]:\n            for subitems in cartesian_product(*iterables[1:]):\n                yield (item,) + subitems"}
{"task_id": "codeeval-2", "solution": "from dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    handle: str\n    def __post_init__(self):\n        handles = [user.handle for user in User.__dataclass_fields__]\n        if handles.count(self.handle) > 1:\n            raise AttributeError('Cannot create 'User' instance - 'handle' attribute conflict.')"}
{"task_id": "codeeval-3", "solution": "def get_random_element(l):\n    import random\n    return l[random.randint(0, len(l)-1)]"}
{"task_id": "codeeval-4", "solution": "return [tuple(t) for t in product(list1, list2)]"}
{"task_id": "codeeval-5", "solution": "def apply_to_list(func, list):\n        return [func(el) for el in list]"}
{"task_id": "codeeval-6", "solution": "def __init__(self, x, y, z):\nself.x = x\nself.y = y\nself.z = z\n\ndef __str__(self):\nreturn f'({self.x}:{self.y}:{self.z})'"}
{"task_id": "codeeval-7", "solution": "def process_list(arg):\n    if type(arg)==list and len(arg)!=0:\n        if type(arg[0])==int:\n            result=0\n            for i in arg:\n                result+=i\n            return result\n        if type(arg[0])==str:\n            result=''\n            for i in arg:\n                result+=i\n            return result\n    else:\n        return None"}
{"task_id": "codeeval-8", "solution": "def check_arguments(a, b, c, d):\n    if not isinstance(a, int):\n        raise TypeError('a must be an integer')\n    if not isinstance(b, int):\n        raise TypeError('b must be an integer')\n    if not isinstance(c, int):\n        raise TypeError('c must be an integer')\n    if not isinstance(d, tuple):\n        raise TypeError('d must be a tuple')\n    if len(d)!= 2:\n        raise ValueError('d must be of size 2')\n    if not isinstance(d[0], int):\n        raise TypeError('d[0] must be an integer')\n    if not isinstance(d[1], str):\n        raise TypeError('d[1] must be a string')"}
{"task_id": "codeeval-9", "solution": "import random\n\nclass Dice:\n    def __init__(self, num_faces=6):\n        self.num_faces = num_faces\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        num = random.randint(1, self.num_faces)\n        if num == 6:\n            raise StopIteration\n        return num"}
{"task_id": "codeeval-10", "solution": "def sort_by_second_field(tuples_list):\n    return sorted(tuples_list, key="}
{"task_id": "codeeval-11", "solution": "class MyClass(object):\n    def __init__(self, value):\n        self.value = value\n\n    def __eq__(self, other):\n        return super(MyClass, self).__eq__(other) or self.value == other.value\n\n    def __str__(self):\n        return str(self.value)"}
{"task_id": "codeeval-12", "solution": "import random\ndef dice():\n    while True:\n        yield random.randint(1, 6)"}
{"task_id": "codeeval-13", "solution": "from collections import Counter\ndef count_elements(lst):\n    return dict(Counter(lst))"}
{"task_id": "codeeval-14", "solution": "def remove_last_item(lst):\n    lst.pop()\n    return lst"}
{"task_id": "codeeval-15", "solution": "#MyClass\n#   private_var\n#end"}
{"task_id": "codeeval-16", "solution": "def __init__(self, name: str, groups: list[str] = None, location: str = 'unknown') -> None:\nself.name = name\nself.groups = groups if groups else []\nself.location = location\n\n# Return a string representation of the object.\ndef __str__(self) -> str:\nreturn f'Person(name='{self.name}', groups={self.groups}, location='{self.location}')'\n\n# Return True if 'other' is an object of the same class as this object and all its attributes equal the corresponding attributes of this object. Otherwise return False.\ndef __eq__(self, other: object) -> bool:\nreturn isinstance(other, self.__class__) and \\n       self.name == other.name and \\n       self.groups == other.groups and \\n       self.location == other.location"}
{"task_id": "codeeval-17", "solution": "def remove_last_item(list):\n  return list[:-1]"}
{"task_id": "codeeval-18", "solution": "class MyClass:\n    def __init__(self, *args, **kwargs):\n        if args:\n            for arg in args:\n                setattr(self, arg, arg)\n        if kwargs:\n            for k, v in kwargs.items():\n                setattr(self, k, v)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        pass"}
{"task_id": "codeeval-19", "solution": "class Sentence:\n    def __init__(self, sentence):\n        self.sentence = sentence\n\n    def __iter__(self):\n        return SentenceIter(self.sentence)\n\n\nclass SentenceIter:\n    def __init__(self, sentence):\n        self.sentence = sentence\n        self.words = self.sentence.split()\n        self.index = 0\n\n    def __next__(self):\n        if self.index == len(self.words):\n            raise StopIteration\n        word = self.words[self.index]\n        self.index += 1\n        return word"}
{"task_id": "codeeval-20", "solution": "import json\n\nclass Vector3d(object):\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    @classmethod\n    def fromjson(cls, jsonstring):\n        values = json.loads(jsonstring)\n        return cls(**values)\n\n    def sign(self, number):\n        if number == 0:\n            return 0\n        return 1 if number > 0 else -1"}
{"task_id": "codeeval-21", "solution": ""}
{"task_id": "codeeval-22", "solution": ">>> pos_key('a', 'b', c='c')\n'abc'\n\n# return a + b + c"}
{"task_id": "codeeval-23", "solution": "# 1. Create a class named 'Vector' that represents a vector of any dimension, and can be instantiated with an iterable.\n# 2. Implement the required special method such that the class supports instance variable assignment and retrieval by index (i.e. vector[0] = 7).\n# 3. Your class should have a dimension property that indicates the length of the vector."}
{"task_id": "codeeval-24", "solution": "def find_common_elements(list1, list2):\n    # Initialize an empty list: common_elements\n    common_elements = []\n\n    # Iterate over list1\n    for ele in list1:\n        # Iterate over list2\n        for ele2 in list2:\n            # Check for a match: is_match\n            is_match = ele == ele2\n\n            # If there is a match and ele is not in common_elements,\n            if is_match and ele not in common_elements:\n\n                # Add ele to common_elements\n                common_elements.append(ele)\n\n    # Return common_elements\n    return sorted(common_elements)"}
{"task_id": "codeeval-25", "solution": "if not isinstance(cls_name, str):\n    raise TypeError('cls_name must be a string value')"}
{"task_id": "codeeval-26", "solution": "Write a test function, 'test_measure_runtime', that takes a non-trivial function f, decorates it with'measure_runtime' and calls it twice. It prints the result as:\n\n<function name> took <time> and returned <value>\n\nfor example:\n\n>>> from decorators_fun import measure_runtime\n>>> def test(x, y=0): return x + y\n>>> measure_runtime(test)(1, 2)\n(0.00010985715441894531, 3)"}
{"task_id": "codeeval-27", "solution": "def sort_by_length(words):\n    words.sort(key=len)\n    return words"}
{"task_id": "codeeval-28", "solution": "def multiply(a, b):\n    return a * b\n\n\ndef double(a):\n    return multiply(a, 2)"}
{"task_id": "codeeval-29", "solution": "def add_list_to_set(lst, set):\n    for x in lst:\n        set.add(x)"}
{"task_id": "codeeval-30", "solution": "code_points = []\nfor c in s:\n    code_points.append(ord(c))\nreturn code_points"}
{"task_id": "codeeval-31", "solution": "def sort_descending(lst):\n    return sorted(lst, key=lambda x: x[::-1])"}
{"task_id": "codeeval-32", "solution": "def __init__(self, iterable):\n    self.iterable = iterable\n\nfor idx, value in enumerate(self.iterable):\n    self.__setattr__(f'x{idx}', value)\n\ndef __getattr__(self, item):\n    return self.__dict__[item]\n\ndef __setattr__(self, key, value):\n    self.__dict__[key] = value"}
{"task_id": "codeeval-33", "solution": "def test_7_abstract_base_class_can_be_subclassed(self):\nimport abc\nclass A(abc.ABC):\n    pass\nclass B(A):\n    pass"}
{"task_id": "codeeval-34", "solution": "def select_random_elements(n: int) -> list:\n        if n < 5 or n > 100:\n            raise ValueError('n must be between 5 and 100, inclusive.')\n        from random import randint\n        # Create a list of numbers from 0 to n-1.\n        # Sample 5 of the numbers.\n        # Return the sampled list.\n        return [randint(0, n - 1) for _ in range(5)]"}
{"task_id": "codeeval-35", "solution": "def find_common_keys(d1, d2):\n    return d1.keys() & d2.keys()"}
{"task_id": "codeeval-36", "solution": "import struct\nimport os\nimport pathlib\n\n\ndef read_double_precision_floats_file(filepath):\n    # Check to make sure the file exists\n    if not os.path.exists(filepath):\n        raise FileNotFoundError(f'File {filepath} does not exist')\n\n    if not os.path.isfile(filepath):\n        raise FileNotFoundError(f'File {filepath} is not a file')\n\n    # Check to make sure the file is the correct type\n    # get file type extension\n    filetype = pathlib.Path(filepath).suffixes\n\n    # check to see if it's a file type we know how to handle\n    if 'bin' not in filetype:\n        raise ValueError(f'File {filepath} is not of a file type we know how to handle')\n\n    # get the byte size\n    file_size = os.path.getsize"}
{"task_id": "codeeval-37", "solution": "1.5: Create an object of class B which is a subclass of A"}
{"task_id": "codeeval-38", "solution": "import asyncio\n\ndef process_single_sentence(sentence, index):\n    return {index: len(sentence.split(' '))}\n\ndef process_many_sentences(sentences):\n    return [asyncio.create_task(process_single_sentence(s, i)) for i, s in enumerate(sentences)]\n\nasync def main(filepath):\n    with open(filepath, 'r') as f:\n        sentences = f.read().splitlines()\n    print(await process_many_sentences(sentences))"}
{"task_id": "codeeval-39", "solution": "def add_list_to_tuple(tuple, list):\n    return tuple + tuple(list)"}
{"task_id": "codeeval-40", "solution": "def list_to_string(arr):\n        return ','.join(arr)"}
{"task_id": "codeeval-41", "solution": "def sort_list(list_of_stuff):\n    # write code here\n    ints = []\n    strings = []\n    for item in list_of_stuff:\n    if type(item) is int:\n        ints.append(item)\n    else:\n        strings.append(item)\n    return sorted(ints) + sorted(strings, reverse=True)"}
{"task_id": "codeeval-42", "solution": "# Example:\n# v1 = Vector3d(1, 2, 3)\n# v2 = Vector3d(1, 2, 3)\n# print(v1 == v2) # true\n# v3 = Vector3d(1, 2, 4)\n# print(v1 == v3) # false\n# Your class definition should not extend any other class."}
{"task_id": "codeeval-43", "solution": "class Sequence(ABC):\n    @abstractmethod\n    def __init__(self):\n        pass\n\n    @abstractmethod\n    def __getitem__(self):\n        pass\n\n    @abstractmethod\n    def __repr__(self):\n        pass\n\n\nclass Sentence(Sequence):\n    def __init__(self, s):\n        self._words = s.split()\n\n    def __getitem__(self, i):\n        return self._words[i]\n\n    def __repr__(self):\n        return''.join(self._words)"}
{"task_id": "codeeval-44", "solution": "class Coordinate:\n    def __init__(self, latitude, longitude):\n        self.latitude = latitude\n        self.longitude = longitude\n\n    def __eq__(self, other):\n        return self.latitude == other.latitude and self.longitude == other.longitude"}
{"task_id": "codeeval-45", "solution": "class Vector3d:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __format__(self, format_spec):\n        return format_spec.upper() + '({:.2f}, {:.2f}, {:.2f})'.format(self.x, self.y, self.z)"}
{"task_id": "codeeval-46", "solution": "def reverse_string(string):\n    \"\"\"Reverse a given string.\"\"\"\n    # return string[::-1]\n    reversed = ''\n    for char in string:\n        reversed = char + reversed\n    return reversed"}
{"task_id": "codeeval-47", "solution": "class Vector():\n    def __init__(self, iterable):\n        self._data = list(iterable)\n\n    def __getitem__(self, item):\n        return self._data[item]\n\n    def __repr__(self):\n        return self._data.__repr__()\n\n    def __len__(self):\n        return self._data.__len__()"}
{"task_id": "codeeval-48", "solution": "# Tip - We can use a dictionary to cache the results\n\n\n# Approach 1 - Naive recursive implementation\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)"}
{"task_id": "codeeval-49", "solution": "import random\n\nclass RandomElement:\n    def __init__(self, iterable):\n        self.iterable = list(iterable)\n        self.i = 0\n\n    def __call__(self):\n        self.i = random.randint(0, len(self.iterable))\n        return self.iterable[self.i]"}
{"task_id": "codeeval-50", "solution": "class Deque:\n\n    def __init__(self):\n        self.items = []\n\n    def add_front(self, val):\n        self.items.insert(0, val)\n\n    def add_rear(self, val):\n        self.items.append(val)\n\n    def remove_front(self):\n        if self.size() == 0:\n            return None\n        return self.items.pop(0)\n\n    def remove_rear(self):\n        if self.size() == 0:\n            return None\n        return self.items.pop()\n\n    def peek_front(self):\n        if self.size() == 0:\n            return None\n        return self.items[0]\n\n    def peek_rear(self):\n        if self.size() == 0:\n            return None\n        return self.items[-1]\n\n    def size(self):\n        return len(self.items)\n\n    def is_empty(self):\n        return self.items == []\n\n\ndef main():\n    my_deque = Deque()"}
{"task_id": "codeeval-51", "solution": "def get_last_inserted_key(dict):\n    result = 0\n    list_keys = list(dict.keys())\n    list_keys.sort()\n    if len(list_keys)!= 0:\n        result = list_keys[-1]\n    return result"}
{"task_id": "codeeval-52", "solution": "def process_single_sentence(sentence, sentence_index, sentence_count):\n    words = sentence.split()\n    return {\n        'location_index': sentence_index,\n       'sentence_count': sentence_count,\n        'word_count': len(words)\n    }\n\nasync def process_many_sentences(sentences, sentence_count):\n    result = []\n    # Complete the following function.\n\n    return result"}
{"task_id": "codeeval-53", "solution": "def get_mro(cls):\n    pass"}
{"task_id": "codeeval-54", "solution": "class Vector3d:\n\n    def __init__(self,x,y,z):\n        self.x = x\n        self.y = y\n        self.z = z\n    \n    def __hash__(self):\n        return hash(self.x*self.x + self.y*self.y + self.z*self.z)"}
{"task_id": "codeeval-55", "solution": ""}
{"task_id": "codeeval-56", "solution": ""}
{"task_id": "codeeval-57", "solution": "def reverse_words(self, sentence):\n        pass"}
{"task_id": "codeeval-58", "solution": "from decimal_context import decimal_context\n\ndef function_to_be_tested():\n    with decimal_context():\n        # Code in here is run within a 'decimal_context'\n\n    # Code in here is run outside the 'decimal_context'"}
{"task_id": "codeeval-59", "solution": "import collections\n\nwords = ['what', 'is', 'going', 'on']\n\nwords_counter = collections.Counter(words)"}
{"task_id": "codeeval-60", "solution": "def merge_dicts(keys: list[str], *args) -> dict:\n    \"\"\"Returns a dictionary from given lists of keys and dictionaries.\"\"\"\n    return dict(zip(keys, args))"}
{"task_id": "codeeval-61", "solution": "def find_largest_n_elements(l, n):\n    return sorted(l)[-n:]"}
{"task_id": "codeeval-62", "solution": "def create_dict(list):\n    dictionary = {}\n    for item in list:\n        dictionary[item[0]] = item[1]\n    return dictionary"}
{"task_id": "codeeval-63", "solution": "def count_element(lst, e):\n    count = 0\n    for i in lst:\n        if i == e:\n            count += 1\n    return count"}
{"task_id": "codeeval-64", "solution": "class Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector2D(self.x + other.x, self.y + other.y)"}
{"task_id": "codeeval-65", "solution": "def get_num_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in text:\n        if i in vowels:\n            count += 1\n    return count"}
{"task_id": "codeeval-66", "solution": "class DecimalContext:\n    def __init__(self,precision):\n        self.precision = precision\n\n    def __enter__(self):\n        self.saved = getcontext().prec\n        getcontext().prec = self.precision\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        getcontext().prec = self.saved"}
{"task_id": "codeeval-67", "solution": "def deduplicate_list(input_list):\n    \"\"\"\n    Returns a de-duplicated list from a given list while preserving the order of the original list.\n    \"\"\"\n    output_list = []\n    for item in input_list:\n        if item not in output_list:\n            output_list.append(item)\n    return output_list"}
{"task_id": "codeeval-68", "solution": "def check_division_equality(a, b, c, d):\n    \n    check1 = a / b\n    check2 = c / d\n    if check1 == check2:\n        return True\n    else: return False"}
{"task_id": "codeeval-69", "solution": "def __init__(self, length, width):\nself.length = length\nself.width = width\n\ndef __repr__(self):\nreturn f'Rectangle({self.length!r}, {self.width!r})'"}
{"task_id": "codeeval-70", "solution": "class Vector2d:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __mul__(self, other):\n        return Vector2d(self.x * other, self.y * other)\n    def __rmul__(self, other):\n        return Vector2d(self.x * other, self.y * other)\n    def __str__(self):\n        return 'Vector2d(' + str(self.x) + ','+ str(self.y) + ')'"}
{"task_id": "codeeval-71", "solution": "def get_last_element(gen_obj):\n    # Initialize the 'last_element' variable\n    last_element = None\n\n    # Iterate over the 'gen_obj' object\n    for element in gen_obj:\n        # Update the 'last_element' variable\n        last_element = element\n\n    # Return the 'last_element' variable\n    return last_element"}
{"task_id": "codeeval-72", "solution": "def every_other_element(elements: List):\n        return elements[::2]"}
{"task_id": "codeeval-73", "solution": ""}
{"task_id": "codeeval-74", "solution": "def deep_copy_list(list_to_copy):\n    new_list = []\n    for item in list_to_copy:\n        if not isinstance(item, list):\n            new_list.append(item)\n        else:\n            new_list.append(deep_copy_list(item))\n    return new_list"}
{"task_id": "codeeval-75", "solution": "import asyncio\nimport time\n\nasync def process_single_sentence(sentence, sentence_index):\n    time.sleep(1)\n    print(sentence)\n    print(sentence_index)\n    return sentence_index\n\nasync def process_many_sentences(sentences):\n    awaitables = []\n    for i, sentence in enumerate(sentences):\n        awaitables.append(process_single_sentence(sentence, i))\n    for f in asyncio.as_completed(awaitables):\n        yield await f"}
{"task_id": "codeeval-76", "solution": "from itertools import accumulate\nfrom typing import Iterable, List\n\n\ndef running_sum(given_list: List[float]) -> Iterable:\n    return accumulate(given_list)"}
{"task_id": "codeeval-77", "solution": "class Vector2d(Sequence):\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return f'Vector2d({self.x}, {self.y})'\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __add__(self, other):\n        return Vector2d(self.x + other.x, self.y + other.y)\n\n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self\n\n    def __len__(self):\n        return 2\n\n    def __getitem__(self, index):\n        if index == 0:\n            return self.x\n        elif index == 1:\n            return self.y\n\n        raise IndexError('Index out of range')"}
{"task_id": "codeeval-78", "solution": "class User:\n    def __init__(self, name, handle):\n        self.name = name\n        self.handle = handle\n\n    def __str__(self):\n        return self.name"}
{"task_id": "codeeval-79", "solution": ""}
{"task_id": "codeeval-80", "solution": "def process_single_sentence(s, i):\n    return {i: len(s.split()}\nasync def process_many_sentences(sentences_list):\n    # get a list of awaitable process_single_sentence tasks\n    process_many_sentences_tasks = [asyncio.ensure_future(process_"}
{"task_id": "codeeval-81", "solution": "def multiply_numbers(lst):\n    prod = 1\n    if lst:\n        for i in lst:\n            prod *= i\n    else:\n        return None\n    return prod"}
{"task_id": "codeeval-82", "solution": ""}
{"task_id": "codeeval-83", "solution": "return (word for word in sentence.split())"}
{"task_id": "codeeval-84", "solution": "class Vector2d:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector2d(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2d(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, k):\n        return Vector2d(self.x * k, self.y * k)\n\n    def __str__(self):\n        return f'Vector2d({self.x}, {self.y})'"}
{"task_id": "codeeval-85", "solution": "class Temperature:\n    def __init__(self, temperature=0):\n        # Your code here\n\n    def celsius(self):\n        # Your code here\n\n    def fahrenheit(self):\n        # Your code here\n\n    def kelvin(self):\n        # Your code here"}
{"task_id": "codeeval-86", "solution": "class CircularList(list):\n    def __getitem__(self, i):\n        return super().__getitem__(i % len(self))"}
{"task_id": "codeeval-87", "solution": "class BankAccount(object):\n    def __init__(self, initial_balance=0.0):\n        self.initial_balance = initial_balance\n\n    def create_account(self, account_type):\n        with sqlite3.connect('example.db') as conn:\n            c = conn.cursor()\n            c.execute(\"INSERT INTO accounts (holder, balance, account_type) VALUES (?,?,?) \", ('me', self.initial_balance, account_type))\n            conn.commit()"}
{"task_id": "codeeval-88", "solution": "class UniqueList():\n    def __init__(self,lst=None):\n        self.lst = lst\n        self.elements = self.lst\n        self.lst.append(self.elements)\n\n    def append(self,item):\n        self.lst.append(item)\n        for i in self.lst:\n            if item in self.lst:\n                raise ValueError('Item already exists')"}
{"task_id": "codeeval-89", "solution": ""}
{"task_id": "codeeval-90", "solution": "class EmailService:\n    def send_email(self, message, to_address):\n        return \"message:\" + to_address\n\nclass EmailClient:\n    def __init__(self, email_service):\n        self.email_service = email_service\n\n    def compose_and_send_email(self, message, to_address):\n        self.email_service.send_email(message, to_address)\n        return \"message:\" + to_address + \" from EmailClient\""}
{"task_id": "codeeval-91", "solution": "class MyDate:\n\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    def from_string(self):\n        if self.year.isdigit() == True and self.month.isdigit() == True and self.day.isdigit() == True:\n            return MyDate(self.year, self.month, self.day)"}
{"task_id": "codeeval-92", "solution": "class Singleton:\n    def __init__(self, decorated):\n        self._decorated = decorated\n\n    def get_instance(self, *args, **kwargs):\n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._decorated(*args, **kwargs)\n            return self._instance\n\n    def __call__(self):\n        raise TypeError(\"Singletons must be accessed through `get_instance()`.\")\n\n    def __instancecheck__(self, inst):\n        return isinstance(inst, self._decorated)"}
{"task_id": "codeeval-93", "solution": "class Vehicle(object):\n    def __init__(self,make,model):\n        self.make = make\n        self.model = model\n    def describe(self):\n        return \"make:model\"\nclass Car(Vehicle):\n    def __init__(self,make,model,mileage):\n        Vehicle.__init__(self,make,model)\n        self.mileage = mileage\n    def describe(self):\n        return \"make:model:mileage\"\nclass Truck(Vehicle):\n    def __init__(self,make,model,capacity):\n        Vehicle.__init__(self,make,model)\n        self.capacity = capacity\n    def describe(self):\n        return \"make:model:capacity\""}
{"task_id": "codeeval-94", "solution": ""}
{"task_id": "codeeval-95", "solution": ""}
{"task_id": "codeeval-96", "solution": "class Lamp:\n    def __init__(self, Lightbulb):\n        self.Lightbulb = Lightbulb\n\n    def switch_on(self):\n        return self.Lightbulb.turn_on()\n\n    def switch_off(self):\n        return self.Lightbulb.turn_off()\n\n\nclass Lightbulb:\n    def turn_on(self):\n        return \"Lightbulb on\"\n\n    def turn_off(self):\n        return \"Lightbulb off\""}
{"task_id": "codeeval-97", "solution": "class MethodAdder(type):\n    def __new__(self, name, bases, attrs):\n        def hello(self):\n            return \"Hello from %s\" % self.__class__.__name__\n        attrs[\"hello\"] = hello\n        return type.__new__(self, name, bases, attrs)"}
{"task_id": "codeeval-98", "solution": "class Singleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]"}
{"task_id": "codeeval-99", "solution": "class JSONSerializableMixin(object):\n\n    def to_json(self):\n        return json.dumps(self.__dict__)\n\n    @classmethod\n    def from_json(cls, json_data):\n        class_name = cls.__name__\n        obj = cls()\n        obj.__dict__ = json.loads(json_data)\n        return obj"}
