{"task_id": "codeeval-0", "problem": "Write a singledispatch decorator Python function named 'process_argument' that supports single argument decorated functions whose behavior change depending on the type of argument passed. If argument is an integer, it returns its absoluate value. If the argument is a string, it turns its len. For all other types of arguments, it returns None", "topic": "decorator", "object": "function", "name": "process_argument", "canonical_solution": "from functools import singledispatch\n\n@singledispatch\ndef process_argument(arg):\n    return None\n\n@process_argument.register(int)\ndef _(arg):\n    return abs(arg)\n\n@process_argument.register(str)\ndef _(arg):\n    return len(arg)", "tests": "[{'assertion': 'func(10) == 10'},  {'assertion': 'func(-5) == 5'},  {'assertion': 'func(\"Hello\") == 5'}, {'assertion': 'func(\"Hello\") == 5'}, {'assertion': 'func([1,2,3]) == None'},{'assertion': 'func(9) == 9'}, {'assertion': 'func(10) == 10'}, {'assertion': 'func(11) == 11'}, {'assertion': 'func(-6) == 6'}, {'assertion': 'func(-5) == 5'}, {'assertion': 'func(-4) == 4'}, {'assertion': 'func(\"Hllo\") == 4'}, {'assertion': 'func(\"Hello\") == 5'}, {'assertion': 'func(\"Hlo\") == 3'}, {'assertion': 'func(\"Hel\") == 3'}, {'assertion': 'func(\"HelloHello\") == 10'}, {'assertion': 'func(\"loHloelollolloolo\") == 17'}, {'assertion': 'func(\"Hllollo\") == 7'}, {'assertion': 'func(\"Hello\") == 5'}, {'assertion': 'func(\"Helello\") == 7'}, {'assertion': 'func(\"llo\") == 3'}, {'assertion': 'func(\"Helloe\") == 6'}, {'assertion': 'func(\"Helloel\") == 7'}, {'assertion': 'func(\"Hellol\") == 6'}, {'assertion': 'func([3, 4, 4, 4]) == None'}]", "complexity": 3}
{"task_id": "codeeval-1", "problem": "Create a Python generator function named 'cartesian_product' that takes multiple iterables and yields cartesian product of the items in the iterables", "topic": "iterator", "object": "function", "name": "cartesian_product", "canonical_solution": "import itertools\n\ndef cartesian_product(*iterables):\n    for item in itertools.product(*iterables):\n        yield item", "tests": "[{'ctx': 'iter1 = [\"A\", \"B\"]\\niter2 = [1, 2, 3]\\niter3 = [\"X\", \"Y\"]\\nr = func(iter1, iter2, iter3)', 'assertion': 'list(r) ==  [(\"A\", 1, \"X\"), (\"A\", 1, \"Y\"), (\"A\", 2, \"X\"), (\"A\", 2, \"Y\"), (\"A\", 3, \"X\"), (\"A\", 3, \"Y\"), (\"B\", 1, \"X\"), (\"B\", 1, \"Y\"), (\"B\", 2, \"X\"), (\"B\", 2, \"Y\"), (\"B\", 3, \"X\"), (\"B\", 3, \"Y\")]'}, {'ctx': 'iter1 = [\"A\", \"B\"]\\niter2 = [1, 2, 3]\\niter3 = [\"X\", \"Y\"]\\niter4 = []\\nr = func(iter1, iter2, iter3, iter4)', 'assertion': 'list(r) ==  []'}, {'ctx': 'iter1 = [\"A\", \"B\"]\\nr = func(iter1)', 'assertion': 'list(r) == [(\"A\",), (\"B\",)]'}]", "complexity": 2}
{"task_id": "codeeval-2", "problem": "Using dataclass, create a Python class named 'User' that holds two instance attributes - 'name' of type str and 'handle' of type str. The class shouldn't allow any two instances to have the same 'handle'", "topic": "dataclass", "object": "class", "name": "User", "canonical_solution": "from dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    handle: str\n\n    _used_handles = set()\n\n    def __post_init__(self):\n        if self.handle in self._used_handles:\n            raise ValueError(f'The handle already exists.')\n        self._used_handles.add(self.handle)", "tests": "[{'ctx': 'error = False\\nobj1 = cls(\"John\", \"@john\")\\ntry:\\n    obj2 = cls(\"Johnathan\", \"@john1\")\\nexcept ValueError:\\n    error = True', 'assertion': 'error == False'},  {'ctx': 'error = False\\nobj3 = cls(\"Jack\", \"@jak\")\\ntry:\\n    obj4 = cls(\"Jockson\", \"@jak\")\\nexcept ValueError:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 3}
{"task_id": "codeeval-3", "problem": "Write a Python function named 'get_random_element' that returns a random element from a given list", "topic": "random module", "object": "function", "name": "get_random_element", "canonical_solution": "import random\ndef get_random_element(lst):\n    if not lst:\n        return None\n    return random.choice(lst)", "tests": "[{'assertion': 'func([100]) == 100'}, {'assertion': 'func([1,2,3]) in [3,1,2]'}, {'assertion': 'func([]) is None'}, {'assertion': 'func([\"a\", \"b\", \"c\"]) in [\"a\", \"b\", \"c\"]'},{'assertion': 'func([100, 100, 100]) == 100'}, {'assertion': 'func([]) == None'}, {'assertion': 'func([\\'a\\', \\'a\\', \\'b\\', \\'b\\', \\'\\', \\'b\\']) == \"a\"'}]", "complexity": 1}
{"task_id": "codeeval-4", "problem": "Write a Python function named 'generate_pairs' that generates a list of tuples with every pair possible from the given two lists", "topic": "tuple", "object": "function", "name": "generate_pairs", "canonical_solution": "def generate_pairs(list1, list2):\n    pairs = []\n    \n    for item1 in list1:\n        for item2 in list2:\n            pair = (item1, item2)\n            pairs.append(pair)\n    \n    return pairs", "tests": "[{'assertion': 'func([1, 2], [\"a\", \"b\"]) == [(1, \"a\"), (1, \"b\"), (2, \"a\"), (2, \"b\")]'},  {'assertion': 'func([10, 20, 30], [\"X\", \"Y\"]) == [(10, \"X\"), (10, \"Y\"), (20, \"X\"), (20, \"Y\"), (30, \"X\"), (30, \"Y\")]'},  {'assertion': 'func([4,7,9], []) == []'},  {'assertion': 'func([], [1,2,3]) == []'}]", "complexity": 1}
{"task_id": "codeeval-5", "problem": "Create a Python higher-order function named 'apply_to_list' that takes a function and a list, applies the function to each element in the list and returns the resulting list", "topic": "functional programming", "object": "function", "name": "apply_to_list", "canonical_solution": "def apply_to_list(func, lst):\n    return [func(x) for x in lst]", "tests": "[{'assertion': 'func(lambda x: x * 2, [1, 2, 3, 4, 5]) == [2, 4, 6, 8, 10]'}, {'assertion': 'func(lambda x: x * 2, []) == []'}, {'assertion': 'func(lambda x: x * 2, [10]) == [20]'}]", "complexity": 2}
{"task_id": "codeeval-6", "problem": "Create a Python class named 'Vector3d' that represents a three dimensional vector. The class can be instantiated with three positional arguments representing x, y and z component of the vector. Implement __str__ method such that it's string representation displays in parenthesis it's x, y and z components delimited by a colon", "topic": "pythonic object", "object": "class", "name": "Vector3d", "canonical_solution": "class Vector3d:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __str__(self):\n        return f'({self.x}:{self.y}:{self.z})'", "tests": "[{'ctx': 'obj = cls(1, 2, 3)', 'assertion': 'obj.x == 1 and obj.y == 2 and obj.z == 3'},   {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},   {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2, 3, 4)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},   {'ctx': 'obj = cls(1, 2, 3)\\ns = str(obj)', 'assertion': 's == \"(1:2:3)\"'}]", "complexity": 2}
{"task_id": "codeeval-7", "problem": "Write a single argument Python function named 'process_list' whose behavior changes depending on the type of argument passed. If the given argument type is a list of int, the function returns a sum of all the elements in the list. If the given argument type is a list of str, the function returns a concatenated string of all the elements in the list. If the argument type is none of these, then it returns None. The function also returns None if the argument is an empty list", "topic": "typing", "object": "function", "name": "process_list", "canonical_solution": "def process_list(lst):\n    if lst:\n        if isinstance(lst, list):\n            if all(isinstance(item, int) for item in lst):\n                return sum(lst)\n            elif all(isinstance(item, str) for item in lst):\n                return ''.join(lst)\n    return None", "tests": "[{'assertion': 'func([1, 2, 3, 4, 5]) == 15'},  {'assertion': 'func([1, \"apple\", 2, \"banana\"]) == None'},  {'assertion': 'func([\"apple\", \"banana\"]) == \"applebanana\"'},  {'assertion': 'func([]) == None'} ,{'assertion': 'func([1, 2, 3, 1, 2, 2, 2]) == 13'}, {'assertion': \"func([2, 1, 'ae', 2, 'apple']) == None\"}, {'assertion': 'func([]) == None'}]", "complexity": 1}
{"task_id": "codeeval-8", "problem": "Write a Python function named 'check_arguments' to test whether given arguments to the function is of the size 4 and the last argument is a tuple of size 2", "topic": "function argument", "object": "function", "name": "check_arguments", "canonical_solution": "def check_arguments(*args):\n    if len(args) == 4 and len(args[-1]) == 2 and isinstance(args[-1], tuple):\n        return True\n    return False", "tests": "[{'assertion': 'func(1,2,3,(4,5)) == True'},  {'assertion': 'func(1,2,3,(4,5,6)) == False'},  {'assertion': 'func(1,2,3, [4,5]) == False'},  {'assertion': 'func(1,2,3) == False'}, {'ctx': 's = [\"banana\", \"apple\", \"orange\", \"kiwi\"]\\nr = func(s)', 'assertion': 's == [\"banana\", \"apple\", \"orange\", \"kiwi\"]'},{'assertion': 'func((1, 2, 3, (4, 5), 1)) == False'}, {'assertion': 'func((1, 3, (4, 5))) == False'}, {'assertion': 'func((1, 3, 2, 3, (4, 5))) == False'}, {'assertion': 'func((1, 2, 3, (5, 4, 5), (4, 5))) == False'}, {'assertion': 'func((1, 2, 3, (3, 5), (4, 5))) == False'}, {'assertion': 'func((1, 2, 3)) == False'}, {'assertion': 'func((2, 3, (4, 5))) == False'}, {'assertion': 'func((1, 2, 2, 3, (4, 5))) == False'}, {'assertion': 'func((1, 1, 2, 3, (4, 5))) == False'}, {'assertion': 'func((1, 2, 3, (4, 5, 6), (4, 5, 6))) == False'}, {'assertion': 'func((1, 2, 3, (4, 5, 6), 2)) == False'}, {'assertion': 'func((2, 3, (4, 5, 6))) == False'}, {'assertion': 'func((2, 2, 3, (4, 5, 6))) == False'}, {'assertion': 'func((1, 2, 3, (4, 5), (4, 5, 6))) == False'}, {'assertion': 'func((1, 1, 2, 3, (4, 5, 6))) == False'}, {'assertion': 'func((1, 3, (4, 5, 6))) == False'}, {'assertion': 'func((1, 2, 3, (4, 5, 5, 6))) == False'}, {'assertion': 'func((2, 2, 3)) == False'}, {'assertion': 'func((1, 2, 3)) == False'}, {'assertion': 'func((1, 2, 3, 1)) == False'}, {'assertion': 'func((2, 3)) == False'}, {'assertion': 'func((1, 2, 4, 3)) == False'}, {'assertion': 'func((1, 3)) == False'}, {'assertion': 'func((2, 1, 2, 3)) == False'}]", "complexity": 2}
{"task_id": "codeeval-9", "problem": "Create a Python iterator class named 'Dice' that returns a random integer from 1 through 6. The iterator must stop when the function returns 6", "topic": "iterator", "object": "class", "name": "Dice", "canonical_solution": "import random\n\nclass Dice:\n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        roll = random.randint(1, 6)\n        if roll == 6:\n            raise StopIteration\n        return roll", "tests": "[{'ctx': 'dice = cls()\\nerror = False\\nr = None\\ntry:\\n    r = next(dice)\\nexcept StopIteration:\\n    error = True', 'assertion': 'r != 6 or error == True'}, {'ctx': 'import itertools\\ndice = cls()\\nrolls = [r for idx, r in itertools.islice(enumerate(dice), 51)]', 'assertion': '6 not in rolls'}]", "complexity": 3}
{"task_id": "codeeval-10", "problem": "Write a Python function named 'sort_by_second_field' that sorts a given list of tuples of 4 fields by the second field", "topic": "functional programming", "object": "function", "name": "sort_by_second_field", "canonical_solution": "def sort_by_second_field(lst):\n    return sorted(lst, key=lambda x: x[1])", "tests": "[{'assertion': 'func([(1, 4, 2, 5), (2, 3, 1, 6), (3, 1, 4, 2), (4, 2, 3, 1)]) == [(3, 1, 4, 2), (4, 2, 3, 1), (2, 3, 1, 6), (1, 4, 2, 5)]'}, {'assertion': 'func([(8, 6, 5, 3), (7, 6, 9, 1), (2, 1, 3, 6), (5, 1, 4, 8)]) == [(2, 1, 3, 6), (5, 1, 4, 8), (8, 6, 5, 3), (7, 6, 9, 1)]'},{'assertion': 'func([]) == []'}, {'assertion': 'func([(7, 6, 9, 1), (2, 1, 3, 6), (2, 1, 1, 3, 6)]) == [(2, 1, 3, 6), (2, 1, 1, 3, 6), (7, 6, 9, 1)]'}]", "complexity": 2}
{"task_id": "codeeval-11", "problem": "Create a Python class named 'MyClass' which can be instantiated with one instance variable of type int. Implement the '__eq__' special method such that two objects when compared with '==' operator only returns True when they are the same object", "topic": "object identity", "object": "class", "name": "MyClass", "canonical_solution": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n    \n    def __eq__(self, other):\n        if self is other:\n            return True\n        else:\n            return False", "tests": "[{'ctx': 'obj1 = MyClass(5)\\nobj2 = MyClass(10)\\nobj3 = obj1', 'assertion': 'obj1 != obj2 and obj1 == obj3 and obj2 != obj3'}, {'ctx': 'obj1 = MyClass(5)\\nobj2 = MyClass(5)', 'assertion': 'obj1 != obj2'}]", "complexity": 1}
{"task_id": "codeeval-12", "problem": "Create a Python generator function named 'dice' that returns a random integer from 1 through 6. The generator must stop when the function returns 6", "topic": "generator", "object": "function", "name": "dice", "canonical_solution": "import random\n\ndef dice():\n    while True:\n        num = random.randint(1, 6)\n        if num == 6:\n            break\n        yield num", "tests": "[{'ctx': 'dice = func()\\nerror = False\\nr = None\\ntry:\\n    r = next(dice)\\nexcept StopIteration:\\n    error = True', 'assertion': 'r != 6 or error == True'}, {'ctx': 'import itertools\\ndice = func()\\nrolls = [r for idx, r in itertools.islice(enumerate(dice), 51)]', 'assertion': '6 not in rolls'}]", "complexity": 2}
{"task_id": "codeeval-13", "problem": "Write a Python function named 'count_elements' that returns a dictionary of unique items and their corresponding frequency in the given list", "topic": "dictionary", "object": "function", "name": "count_elements", "canonical_solution": "from collections import Counter\ndef count_elements(lst):\n    return Counter(lst) # Counter is a subclass of dict", "tests": "[{'assertion': 'func([1]) == {1:1}'}, {'assertion': 'func([]) == {}'}, {'assertion': 'func([1,2,3,4]) == {1:1, 2:1, 3:1, 4:1}'}, {'assertion': 'func([1, 2, 3, 1, 2, 3, 1, 2, 3]) == {1:3, 2:3, 3:3}'}, {'assertion': 'func([1,1,1,1,1]) == {1:5}'},{'assertion': 'func([0, 0, 0]) == Counter({0: 3})'}, {'assertion': 'func([1, 1, 2, 4, 3, 3, 4, 2]) == Counter({1: 2, 2: 2, 4: 2, 3: 2})'}, {'assertion': 'func([1, 1, 1, 2, 3, 1, 2, 3, 2, 2, 3, 3]) == Counter({1: 4, 2: 4, 3: 4})'}, {'assertion': 'func([3, 2, 1, 1, 1, 1, 1]) == Counter({1: 5, 3: 1, 2: 1})'}]", "complexity": 1}
{"task_id": "codeeval-14", "problem": "Write a Python function named 'remove_last_item' that returns a list after removing the last item in the given list", "topic": "list", "object": "function", "name": "remove_last_item", "canonical_solution": "def remove_last_item(lst):\n    # Check if the list is empty or only has one item\n    if len(lst) <= 1:\n        return []\n    else:\n        # Return the list without the last item\n        return lst[:-1]", "tests": "[{'assertion': 'func([1, 2, 3, 4, 5]) == [1, 2, 3, 4]'}, {'assertion': 'func([1]) == []'}, {'assertion':'func([]) == []'}, {'assertion': 'func([\"Hello\", \"World\", \"!\"]) == [\"Hello\", \"World\"]'}, {'assertion': 'func([False, True, False, True]) == [False, True, False]'},{'assertion': 'func([1, 3, 4, 4, 6, 4, 5, 4, 5, 3]) == [1, 3, 4, 4, 6, 4, 5, 4, 5]'}, {'assertion': 'func([]) == []'}, {'assertion': \"func(['World', 'World', '!!', '!', '!', '!', '!']) == ['World', 'World', '!!', '!', '!', '!']\"}, {'assertion': 'func([True, True, False, True]) == [True, True, False]'}]", "complexity": 1}
{"task_id": "codeeval-15", "problem": "Create a Python class named 'MyClass' with a private instance variable and implement a property method named 'private_var' to return the private instance variable", "topic": "pythonic object", "object": "class", "name": "MyClass", "canonical_solution": "class MyClass:\n    def __init__(self, value):\n        self.__private_var = value\n\n    @property\n    def private_var(self):\n        return self.__private_var", "tests": "[{'ctx': 'c1 = cls(10)', 'assertion': 'c1.private_var == 10'}, {'ctx': 'c1 = cls(10)\\nerror = False\\ntry:\\n    c1.private_var = 30\\nexcept AttributeError:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 2}
{"task_id": "codeeval-16", "problem": "Create a Python dataclass named 'MyClass' with two instance attributes named 'name' and 'groups' and a class attribute named 'location' whose default value is 'unknown'. 'name' is of type str and 'groups' of of type list of str whose default value is an empty list", "topic": "dataclass", "object": "class", "name": "MyClass", "canonical_solution": "from dataclasses import dataclass, field\nfrom typing import List\n\n@dataclass\nclass MyClass:\n    name: str\n    groups: List[str] = field(default_factory=list)\n\n    location = 'unknown'", "tests": "[{'ctx': 'g = [\"g1\", \"g2\"]\\nc1 = cls(\"John\", g)', 'assertion': 'c1.name == \"John\" and c1.groups == g'},  {'ctx': 'c1 = cls(\"John\")', 'assertion': 'c1.name == \"John\" and c1.groups == []'},  {'ctx': 'g = [\"g1\", \"g2\"]\\nc1 = cls(\"John\", g)\\nc1.location = \"LA\"', 'assertion': 'cls.location == \"unknown\"'},  {'ctx': 'g = [\"g1\", \"g2\"]\\nc1 = cls(\"John\", g)\\ncls.location = \"LA\"', 'assertion': 'cls.location == \"LA\" and c1.location == \"LA\"'} ]", "complexity": 3}
{"task_id": "codeeval-17", "problem": "Write a Python function named 'remove_last_item' that returns a new list after removing the last item from the given list without modifying it", "topic": "function argument", "object": "function", "name": "remove_last_item", "canonical_solution": "def remove_last_item(lst):\n    # Check if the list is empty\n    if len(lst) == 0:\n        return []\n\n    # Create a new list without modifying the original\n    new_lst = lst[:-1]\n    return new_lst", "tests": "[{'ctx': 'l1 = [1, 2, 3, 4, 5]\\nl2 = func(l1)', 'assertion': 'l1 == [1, 2, 3, 4, 5] and l2 == [1, 2, 3, 4]'}, {'assertion': 'func([]) == []'},  {'assertion': 'func([10]) == []'}, {'assertion': 'func([\"cat\", \"bat\", \"dog\"]) == [\"cat\", \"bat\"]'},{'assertion': 'func([]) == []'}, {'assertion': \"func(['at', 'at', 'dog', 'dog', 'dogg', 'dog']) == ['at', 'at', 'dog', 'dog', 'dogg']\"}]", "complexity": 2}
{"task_id": "codeeval-18", "problem": "Create a Python class named 'MyClass' that can be instantiated with any number of arguments and implement a special method such that iterating over the object iterates it's instance variables", "topic": "special method", "object": "class", "name": "MyClass", "canonical_solution": "class MyClass:\n    def __init__(self, *args):\n        self.variables = args\n\n    def __iter__(self):\n        return iter(self.variables)", "tests": "[{'ctx': 'c1 = cls(10, 20)\\nerror = False\\ntry:\\n    r = list(c1)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == False and r == [10, 20]'}, {'ctx': 'c1 = cls(10, 20, 30)\\nerror = False\\ntry:\\n    r = list(c1)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == False and r == [10, 20, 30]'}]", "complexity": 3}
{"task_id": "codeeval-19", "problem": "Create a Python iterator class named 'Sentence' which can be instantiated with a string of words. Implement the required special method that will allow iterating one word at a time in the given sentence", "topic": "iterator", "object": "class", "name": "Sentence", "canonical_solution": "class Sentence:\n    def __init__(self, sentence):\n        self.sentence = sentence\n        self.words = sentence.split()\n        self.current_word = 0\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current_word < len(self.words):\n            word = self.words[self.current_word]\n            self.current_word += 1\n            return word\n        else:\n            raise StopIteration()", "tests": "[{'ctx': 'obj = cls(\"A quick brown fox\")', 'assertion': 'list(obj) == [\"A\",\"quick\",\"brown\",\"fox\"]'},   {'ctx': 'obj = cls(\"A quick brown fox\")\\nr = next(obj)', 'assertion': 'r == \"A\"'},   {'ctx': 'obj = cls(\"\")\\nerror = False\\ntry:\\n    next(obj)\\nexcept StopIteration:\\n    error = True', 'assertion': 'error == True'} ]", "complexity": 3}
{"task_id": "codeeval-20", "problem": "Create a Python class named 'Vector3d' that represents a three dimensional vector. The class can be instantiated with three positional arguments representing x, y and z component of the vector. Create a classmethod named 'fromjson' that provides an alternative constructor method to instantiate the Vector3d class given a json string whose keys are 'x', 'y' and 'z'", "topic": "design pattern", "object": "class", "name": "Vector3d", "canonical_solution": "import json\n\nclass Vector3d:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    @classmethod\n    def fromjson(cls, json_string):\n        data = json.loads(json_string)\n        x = data['x']\n        y = data['y']\n        z = data['z']\n        return cls(x, y, z)", "tests": "[{'ctx': 'obj = cls(1, 2, 3)', 'assertion': 'obj.x == 1 and obj.y == 2 and obj.z == 3'},  {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2, 3, 4)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': 'js = \\'{\"x\": 4, \"y\": 5, \"z\": 6}\\'\\nobj = cls.fromjson(js)', 'assertion': 'obj.x == 4 and obj.y == 5 and obj.z == 6'}, {'ctx': 'js = \\'{\"x\": 4, \"y\": 5}\\'\\nerror = False\\ntry:\\n    obj = cls.fromjson(js)\\nexcept KeyError:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 2}
{"task_id": "codeeval-21", "problem": "Create a Python class named 'MyClass' that can be instantiated with two instance variables and implement a special method such that iterating over the object iterates it's instance variables", "topic": "special method", "object": "class", "name": "MyClass", "canonical_solution": "class MyClass:\n    def __init__(self, var1, var2):\n        self.var1 = var1\n        self.var2 = var2\n\n    def __iter__(self):\n        yield self.var1\n        yield self.var2", "tests": "[{'ctx': 'c1 = cls(10, 20)\\nerror = False\\ntry:\\n    r = list(c1)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == False and r == [10, 20]'}]", "complexity": 2}
{"task_id": "codeeval-22", "problem": "Write a Python function named 'positional_keyword_args' that supports positional only arguments of two parameters 'a' and 'b' and a keyword only argument 'c' with no default value. The function returns the sum of a, b and c", "topic": "function argument", "object": "function", "name": "positional_keyword_args", "canonical_solution": "def positional_keyword_args(a, b, *, c):\n    return a + b + c", "tests": "[{'assertion': 'func(1, 2, c=3) == 6'},  {'ctx': 'error = False\\ntry:\\n    func(1,2)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': 'error = False\\ntry:\\n    func(1,2,3)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': 'error = False\\ntry:\\n    func(a=1,b=2,c=3)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == False'},  {'ctx': 'error = False\\ntry:\\n    func(1,2,c=3)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == False'}]", "complexity": 3}
{"task_id": "codeeval-23", "problem": "Create a Python class named 'Vector' that represents a vector of any dimension, and can be instantiated with an iterable. Implement the required special method such that the class supports instance variable assignment and retrieval by index", "topic": "special method", "object": "class", "name": "Vector", "canonical_solution": "class Vector:\n    def __init__(self, iterable):\n        self._vector = list(iterable)\n\n    def __getitem__(self, index):\n        return self._vector[index]\n\n    def __setitem__(self, index, value):\n        self._vector[index] = value", "tests": "[{'ctx': 'obj = cls([1, 2, 3, 4, 5])', 'assertion': 'list(obj) == [1, 2, 3, 4, 5]'},     {'ctx': 'obj = cls([1, 2, 3, 4, 5])\\nobj[1] = 20', 'assertion': 'list(obj) == [1, 20, 3, 4, 5]'},      {'ctx': 'obj = cls([1, 2, 3, 4, 5])', 'assertion': 'obj[3] == 4'}]", "complexity": 2}
{"task_id": "codeeval-24", "problem": "Write a Python function named 'find_common_elements' that returns a list of unique common elements of the given two lists", "topic": "set", "object": "function", "name": "find_common_elements", "canonical_solution": "def find_common_elements(list1, list2):\n    # Find common elements between the two lists\n    common_elements = list(set(list1) & set(list2))\n    \n    # Remove duplicates from common elements list\n    unique_common_elements = list(set(common_elements))\n    \n    return unique_common_elements", "tests": "[{'assertion': 'func([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) == [4,5]'}, {'assertion': 'func([1,2,3], [4,5,6]) == []'}, {'assertion': 'func([], []) == []'}, {'assertion': 'func([1,2,3], []) == []'}, {'assertion': 'func([], [1,2,3]) == []'}, {'assertion': 'func([1, 2, 2, 3, 4, 4, 5], [4, 4, 5, 6, 7, 8]) == [4,5]'}]", "complexity": 1}
{"task_id": "codeeval-25", "problem": "Create a Python abstract base class named 'MyABCClass' with a single parameter abstract method named 'my_abstract_method'", "topic": "inheritance", "object": "class", "name": "MyABCClass", "canonical_solution": "import abc\n\nclass MyABCClass(abc.ABC):\n    \n    @abc.abstractmethod\n    def my_abstract_method(self, param):\n        pass", "tests": "[{'assertion': 'type(cls) == abc.ABCMeta'},  {'ctx': 'error = False\\ntry:\\n    obj1 = cls()\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': 'class MyClass(MyABCClass):\\n    def my_abstract_method(self, param):\\n        return param * 2\\n\\nobj = MyClass()\\nresult = obj.my_abstract_method(5)', 'assertion': 'result == 10'}]", "complexity": 2}
{"task_id": "codeeval-26", "problem": "Write a Python decorator function named 'measure_runtime' that returns a tuple with first element containing the elapsed runtime and the second element containing the return value of the decorated function", "topic": "decorator", "object": "function", "name": "measure_runtime", "canonical_solution": "import time\n\ndef measure_runtime(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        elapsed_time = end_time - start_time\n        return elapsed_time, result\n    return wrapper", "tests": "[{'ctx': 'import math\\n@measure_runtime\\ndef test_func():\\n    time.sleep(2)\\nt1, res = test_func()', 'assertion': 'math.isclose(t1, 2.0, rel_tol=0.1)'}, {'ctx': '@measure_runtime\\ndef test_func():\\n    time.sleep(2)\\nres = test_func()', 'assertion': 'isinstance(res, tuple) and len(res) == 2'}]", "complexity": 3}
{"task_id": "codeeval-27", "problem": "Write a Python function named 'sort_by_length' that sorts a given list of string by its length and returns a new list", "topic": "functional programming", "object": "function", "name": "sort_by_length", "canonical_solution": "def sort_by_length(lst):\n    return sorted(lst, key=len)", "tests": "[{'assertion': 'func([]) == []'},  {'assertion': 'func([\"apple\"]) == [\"apple\"]'},  {'assertion': 'func([\"banana\", \"apple\", \"orange\", \"kiwi\"]) == [\"kiwi\", \"apple\", \"banana\", \"orange\"]'},  {'assertion': 'func([\"cat\", \"dog\", \"bat\"]) == [\"cat\", \"dog\", \"bat\"]'},{'assertion': 'func([]) == []'}, {'assertion': \"func(['apple', 'orange', 'wiwiwwi', 'kiwi', 'orange', 'orangeg', 'orange']) == ['kiwi', 'apple', 'orange', 'orange', 'orange', 'wiwiwwi', 'orangeg']\"}, {'assertion': \"func(['caa', 'ca', 'bat', 'catca', 'cat']) == ['ca', 'caa', 'bat', 'cat', 'catca']\"}]", "complexity": 2}
{"task_id": "codeeval-28", "problem": "Create a Python function named 'multiply' that takes two numbers and returns their product. Using functools module and the 'multiply' function, create another function named 'double' that calculates the double of a number", "topic": "functional programming", "object": "function", "name": "double", "canonical_solution": "import functools\n\ndef multiply(a, b):\n    return a * b\n\ndouble = functools.partial(multiply, b = 2)", "tests": "[{'assertion': 'multiply(4, 2) == 8'}, {'assertion': 'func(4) == 8'}, {'keyword': 'partial'},{'assertion': 'func((4, 3, 2)) == (4, 3, 2, 4, 3, 2)'}, {'assertion': 'func((4, 2, 4)) == (4, 2, 4, 4, 2, 4)'}, {'assertion': 'func((4,)) == (4, 4)'}, {'assertion': 'func((5, 2)) == (5, 2, 5, 2)'}, {'assertion': 'func((4, 1, 2)) == (4, 1, 2, 4, 1, 2)'}, {'assertion': 'func((4, 2, 2)) == (4, 2, 2, 4, 2, 2)'}, {'assertion': 'func(3) == 6'}, {'assertion': 'func(4) == 8'}, {'assertion': 'func(5) == 10'}]", "complexity": 1}
{"task_id": "codeeval-29", "problem": "Write a Python function named 'add_list_to_set(l, s)' to add a given list l to a given set s", "topic": "set", "object": "function", "name": "add_list_to_set", "canonical_solution": "def add_list_to_set(lst, my_set):\n    my_set.update(lst)\n    return my_set", "tests": "[{'assertion': 'func([1,2,3], {4,5,6}) == {1,2,3,4,5,6}'}, {'assertion': 'func([9,8,7], {7,8,9}) == {7,8,9}'}, {'assertion': 'func([10, 20, 30], {20, 30, 40}) == {10, 20, 30, 40}'}, {'assertion': 'func([10, 20, 30, 30, 20], {20, 30, 40}) == {10, 20, 30, 40}'}, {'assertion': 'func([], {20, 30, 40}) == {20, 30, 40}'}, {'assertion': 'func([10, 20, 30], set()) == {10, 20, 30}'}, {'assertion': 'func([], set()) == set()'}]", "complexity": 1}
{"task_id": "codeeval-30", "problem": "Write a Python function named 'get_unicode_code_points' that returns a list of Unicode code points given a string", "topic": "string", "object": "function", "name": "get_unicode_code_points", "canonical_solution": "def get_unicode_code_points(string):\n    code_points = []\n    for char in string:\n        code_points.append(ord(char))\n    return code_points", "tests": "[{'assertion': 'func(\"\") == []'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyz\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]'}, {'assertion': 'func(\"1234567890\") == [49, 50, 51, 52, 53, 54, 55, 56, 57, 48]'}, {'assertion': 'func(\"\ud83d\ude00\ud83c\udf0d\ud83e\udd73\") == [128512, 127757, 129395]'},{'assertion': 'func(\"abcdefrstuvwxyz\") == [97, 98, 99, 100, 101, 102, 114, 115, 116, 117, 118, 119, 120, 121, 122]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyzijklmno\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 105, 106, 107, 108, 109, 110, 111]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyzrst\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 114, 115, 116]'}, {'assertion': 'func(\"abcdefghijklmnopqrs\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxy\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyzv\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 118]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyz\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvw\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyzghijk\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 103, 104, 105, 106, 107]'}, {'assertion': 'func(\"abcdefghijklmnopqrstuvwxyzabcdef\") == [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 97, 98, 99, 100, 101, 102]'}, {'assertion': 'func(\"1\") == [49]'}, {'assertion': 'func(\"12345670\") == [49, 50, 51, 52, 53, 54, 55, 48]'}, {'assertion': 'func(\"1234567890\") == [49, 50, 51, 52, 53, 54, 55, 56, 57, 48]'}, {'assertion': 'func(\"12345678906\") == [49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 54]'}, {'assertion': 'func(\"3451345234533454345534563457345834593450345\") == [51, 52, 53, 49, 51, 52, 53, 50, 51, 52, 53, 51, 51, 52, 53, 52, 51, 52, 53, 53, 51, 52, 53, 54, 51, 52, 53, 55, 51, 52, 53, 56, 51, 52, 53, 57, 51, 52, 53, 48, 51, 52, 53]'}, {'assertion': 'func(\"1234345\") == [49, 50, 51, 52, 51, 52, 53]'}, {'assertion': 'func(\"12345678900\") == [49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 48]'}, {'assertion': 'func(\"12345456789890\") == [49, 50, 51, 52, 53, 52, 53, 54, 55, 56, 57, 56, 57, 48]'}, {'assertion': 'func(\"\ud83d\ude00\ud83e\udd73\") == [128512, 129395]'}, {'assertion': 'func(\"\ud83d\ude00\ud83c\udf0d\ud83e\udd73\ud83d\ude00\ud83c\udf0d\ud83e\udd73\") == [128512, 127757, 129395, 128512, 127757, 129395]'}, {'assertion': 'func(\"\ud83d\ude00\ud83c\udf0d\ud83d\ude00\ud83c\udf0d\") == [128512, 127757, 128512, 127757]'}, {'assertion': 'func(\"\ud83c\udf0d\ud83e\udd73\") == [127757, 129395]'}, {'assertion': 'func(\"\ud83d\ude00\ud83c\udf0d\ud83e\udd73\ud83c\udf0d\") == [128512, 127757, 129395, 127757]'}, {'assertion': 'func(\"\ud83d\ude00\ud83c\udf0d\ud83e\udd73\") == [128512, 127757, 129395]'}, {'assertion': 'func(\"\ud83e\udd73\") == [129395]'}]", "complexity": 1}
{"task_id": "codeeval-31", "problem": "Write a Python function named 'sort_descending' that returns a new list after sorting the given list of str by their reverse spelling", "topic": "functional programming", "object": "function", "name": "sort_descending", "canonical_solution": "def sort_descending(lst):\n    return sorted(lst, key=lambda x: x[::-1])", "tests": "[{'assertion': 'func([\"hello\", \"world\", \"Python\", \"programming\"]) == [\"world\", \"programming\", \"Python\", \"hello\"]'},  {'assertion': 'func([\"hello\"]) == [\"hello\"]'},  {'assertion': 'func([]) == []'},{'assertion': 'func([\"hello\", \"world\", \"P\", \"Pythoo\", \"hello\"]) == [\"P\", \"world\", \"hello\", \"hello\", \"Pythoo\"]'}, {'assertion': 'func([]) == []'}]", "complexity": 2}
{"task_id": "codeeval-32", "problem": "Create a Python class named 'Vector' that represents a vector of any dimension, and can be instantiated with an iterable. The class supports dynamic attributes x, y and z such that x represents the first component, y the second and z the third component. Implement the __getattr__ and __setattr__ special methods to support retrieval and assignment of the dynamic attributes respectively", "topic": "pythonic object", "object": "class", "name": "Vector", "canonical_solution": "class Vector:\n    def __init__(self, iterable):\n        self._vector = list(iterable)\n\n    def __getattr__(self, item):\n        if item in (\"x\", \"y\", \"z\"):\n            if item == \"x\":\n                return self._vector[0] if len(self._vector) >= 1 else None\n            elif item == \"y\":\n                return self._vector[1] if len(self._vector) >= 2 else None\n            elif item == \"z\":\n                return self._vector[2] if len(self._vector) >= 3 else None\n        else:\n            raise AttributeError(f'Vector object has no attribute {item}')\n\n    def __setattr__(self, key, value):\n        if key in (\"x\", \"y\", \"z\"):\n            if key == \"x\":\n                self._vector[0] = value\n            elif key == \"y\":\n                self._vector[1] = value\n            elif key == \"z\":\n                self._vector[2] = value\n        else:\n            super().__setattr__(key, value)", "tests": "[{'ctx': 'obj = cls([1, 2, 3, 4, 5])', 'assertion': 'obj.x == 1 and obj.y == 2 and obj.z == 3'}, {'ctx': 'obj = cls([1, 2, 3, 4, 5])\\nobj.y = 20', 'assertion': 'obj.y == 20'}, {'ctx': 'obj = cls([1, 2, 3, 4, 5])\\nobj.z = 30', 'assertion': 'obj.z == 30'}, {'ctx': 'obj = cls([1, 2, 3, 4, 5])\\nobj.x = 10', 'assertion': 'obj.x == 10'},  {'ctx': 'obj = cls([9, 10, 11])\\nerror = False\\ntry:\\n    obj.w\\nexcept AttributeError:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 3}
{"task_id": "codeeval-33", "problem": "Create a Python abstract base class named 'A' and a mixin class named 'AMixin'. Create a class named 'C' that inherits from class 'A' and 'AMixin'", "topic": "inheritance", "object": "class", "name": "C", "canonical_solution": "import abc\n\nclass A(abc.ABC):\n    pass\n\nclass AMixin:\n    pass\n\nclass C(AMixin, A):\n    pass", "tests": "[{'assertion': 'issubclass(C, A) == True and issubclass(C, AMixin) == True'}, {'ctx': 'm = [c.__name__ for c in C.mro()]', 'assertion': 'm[1] == \"AMixin\"'}]", "complexity": 2}
{"task_id": "codeeval-34", "problem": "Write a Python function named 'select_random_elements' that returns a list of randomly selected non-repeating 5 elements from a range of integers from 0 to the given interger n. The function raises ValueError when n < 5", "topic": "random module", "object": "function", "name": "select_random_elements", "canonical_solution": "import random\n\ndef select_random_elements(n):\n    if n < 5: raise ValueError\n    elements = list(range(n+1))\n    random_elements = random.sample(elements, 5)\n    return random_elements", "tests": "[{'ctx': 'error = False\\ntry:\\n    r = func(4)\\nexcept ValueError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': '', 'assertion': 'len(func(10)) == 5'},  {'ctx': '', 'assertion': 'len(set(func(10))) == 5'}, {'assertion': 'all(0 <= num <= 10 for num in func(10))'}]", "complexity": 1}
{"task_id": "codeeval-35", "problem": "Write a Python function named 'find_common_keys' that returns a set of common keys between the two given dictionaries", "topic": "dictionary", "object": "function", "name": "find_common_keys", "canonical_solution": "def find_common_keys(dict1, dict2):\n    return dict1.keys() & dict2.keys()", "tests": "[{'assertion': 'func({}, {}) == set()'},  {'assertion': 'func({\"a\": 1, \"b\": 2, \"c\": 3}, {\"b\": 4, \"c\": 5, \"d\": 6}) == {\"b\", \"c\"}'},  {'assertion': 'func({\"a\": 1, \"b\": 2, \"c\": 3}, {}) == set()'},  {'assertion': 'func({}, {\"a\": 1, \"b\": 2, \"c\": 3}) == set()'}]", "complexity": 1}
{"task_id": "codeeval-36", "problem": "Given a string path to the file, write a Python function named 'read_double_precision_floats_file' that reads a binary file of an array object of double precision floating point numbers and returns a generator of the object", "topic": "data structure", "object": "function", "name": "read_double_precision_floats_file", "canonical_solution": "import struct\ndef read_double_precision_floats_file(path):\n    with open(path, 'rb') as file:\n        while True:\n            # Read 8 bytes (size of double precision float)\n            data = file.read(8)\n            if not data:\n                break\n            yield struct.unpack('d', data)[0]", "tests": "[{'ctx': 'ag = func(\"runcodeeval/templates/array.bin\")', 'assertion': 'list(ag) == [1.0, 2.5, 3.7, 4.2, 5.9]'},  {'ctx': 'ag = func(\"runcodeeval/templates/array.bin\")', 'assertion': 'next(ag) == 1.0'}]", "complexity": 3}
{"task_id": "codeeval-37", "problem": "Create a Python class named 'class B' which is a virtual subclass of abstract base class named 'class A'", "topic": "inheritance", "object": "class", "name": "B", "canonical_solution": "import abc\n\nclass A(abc.ABC):\n    pass\n\nclass B:\n    pass\n\nA.register(B)", "tests": "[{'assertion': 'issubclass(B, A) == True'}, {'ctx': 'm = [c.__name__ for c in B.mro()]', 'assertion': '\"A\" not in m'}]", "complexity": 2}
{"task_id": "codeeval-38", "problem": "Write an awaitable Python function named 'process_single_sentence(s, i), ' that takes a sentence s of type str and its location index i of type int in a paragraph, and returns a dictionary of location index and the number of words in the sentence. Create another awaitable function named 'process_many_sentences' that given a list of string calls the awaitable process_single_sentence for each sentence in the list. The function returns list of results from awaitables in the order as they were completed", "topic": "concurrency", "object": "function", "name": "process_many_sentences", "canonical_solution": "import asyncio\n\nasync def process_single_sentence(sentence, index):\n    num_words = len(sentence.split())\n    return {index: num_words}\n\nasync def process_many_sentences(sentences):\n    tasks = [process_single_sentence(sentence, index) for index, sentence in enumerate(sentences)]\n    results = []\n    for future in asyncio.as_completed(tasks):\n        result = await future\n        results.append(result)\n    return results", "tests": "[{'ctx': 'from collections import abc\\nsentences = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\ncoro = func(sentences)', 'assertion': 'isinstance(coro, abc.Coroutine) == True'}, {'ctx': 'sentences = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\nr = asyncio.run(func(sentences))', 'assertion': 'sorted(r, key=lambda x: list(x.keys())[0]) == [{0: 4}, {1: 3}, {2: 4}]'},{'keyword': 'asyncio.as_completed'}]", "complexity": 3}
{"task_id": "codeeval-39", "problem": "Write a Python function named 'add_list_to_tuple(lst, tup)' that adds a given list lst to a given tuple tup", "topic": "tuple", "object": "function", "name": "add_list_to_tuple", "canonical_solution": "def add_list_to_tuple(lst, tup):\n    new_tuple = tuple(lst) + tup\n    return new_tuple", "tests": "[{'assertion':'func([1, 2, 3], (4, 5, 6)) == (1, 2, 3, 4, 5, 6)'}, {'assertion': 'func([], (4, 5, 6)) == (4, 5, 6)'}, {'assertion': 'func([1,2,3], ()) == (1,2,3)'}, {'assertion': 'func([], ()) == ()'}]", "complexity": 1}
{"task_id": "codeeval-40", "problem": "Write a Python function named 'list_to_string' that returns a comma separated string of elements in a given list", "topic": "string", "object": "function", "name": "list_to_string", "canonical_solution": "def list_to_string(lst):\n    return ','.join(str(element) for element in lst)", "tests": "[{'assertion': 'func([]) == \"\"'}, {'assertion': 'func([1,2,3,4,5]) == \"1,2,3,4,5\"'}, {'assertion': 'func([\"a\", \"b\",\"c\"]) == \"a,b,c\"'}, {'assertion': 'func([\"one\", 1, \"two\", 2]) == \"one,1,two,2\"'}, {'assertion': 'func([\"abc,def\", \"ghi jkl\"]) == \"abc,def,ghi jkl\"'},{'assertion': 'func([0, 1, 2, 3, 2, 3, 6, 2]) == \"0,1,2,3,2,3,6,2\"'}, {'assertion': 'func([\\'bbbbbbbbbbbbbb\\', \\'bbbbbbbbbbb\\', \\'bbbbbbb\\', \\'b\\', \\'b\\']) == \"bbbbbbbbbbbbbb,bbbbbbbbbbb,bbbbbbb,b,b\"'}, {'assertion': 'func([\\'one\\', \\'one\\', 2, \\'on\\', \\'on\\', 2, \\'on\\', \\'one\\']) == \"one,one,2,on,on,2,on,one\"'}, {'assertion': 'func([\\'abc,def\\', \\'gh jklkl\\', \\'ghi jkl\\', \\'abdef\\', \\'abd\\', \\'abc,def\\']) == \"abc,def,gh jklkl,ghi jkl,abdef,abd,abc,def\"'}]", "complexity": 1}
{"task_id": "codeeval-41", "problem": "Given a non-homogenous list of integers and strings, write a Python function named 'sort_list' that returns a sorted list contaning all integers first in ascending order and then all strings in descending order", "topic": "typing", "object": "function", "name": "sort_list", "canonical_solution": "def sort_list(lst):\n    # separate integers and strings\n    integers = []\n    strings = []\n    for item in lst:\n        if isinstance(item, int):\n            integers.append(item)\n        elif isinstance(item, str):\n            strings.append(item)\n    \n    # sort integers in ascending order\n    integers.sort()\n    \n    # sort strings in descending order\n    strings.sort(reverse=True)\n    \n    sorted_list = integers + strings\n    return sorted_list", "tests": "[{'assertion': 'func([4, \"apple\", 7, \"banana\", 2, \"orange\"]) == [2,4,7, \"orange\", \"banana\", \"apple\", ]'}, {'assertion': 'func([4, 7, 2, 1, 3]) == [1,2,3,4,7]'}, {'assertion': 'func([]) == []'}, {'assertion': 'func([1]) == [1]'}, {'assertion': 'func([\"abc\", \"ghi\", \"def\"]) == [\"ghi\", \"def\", \"abc\"]'},{'assertion': 'func([4, 8, \"banana\", \"oaooaooaooaroaooaaoaooanoaooagoaooaeoaooa\", \"banana\"]) == [4, 8, \"oaooaooaooaroaooaaoaooanoaooagoaooaeoaooa\", \"banana\", \"banana\"]'}, {'assertion': 'func([3, 3, 2, 3, 2]) == [2, 2, 3, 3, 3]'}, {'assertion': 'func([]) == []'}, {'assertion': 'func([\"abc\", \"ghi\", \"ghi\", \"ac\"]) == [\"ghi\", \"ghi\", \"ac\", \"abc\"]'}]", "complexity": 1}
{"task_id": "codeeval-42", "problem": "Create a Python class named 'Vector3d' that represents a three dimensional vector. The class can be instantiated with three positional arguments representing x, y and z component of the vector. Implement a special method such that two Vector3d objects when compared with '==' operator returns True when they have the exact same components", "topic": "special method", "object": "class", "name": "Vector3d", "canonical_solution": "class Vector3d:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __eq__(self, other):\n        if isinstance(other, Vector3d):\n            return self.x == other.x and self.y == other.y and self.z == other.z\n        return False", "tests": "[{'ctx': 'obj = cls(1, 2, 3)', 'assertion': 'obj.x == 1 and obj.y == 2 and obj.z == 3'},  {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},  {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2, 3, 4)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},     {'ctx': 'obj1 = cls(10, 20, 30)\\nobj2 = cls(10, 20, 30)', 'assertion': 'obj1 == obj2'}, {'ctx': 'obj1 = cls(10, 20, 30)\\nobj2 = cls(1, 2, 3)', 'assertion': 'obj1 != obj2'}]", "complexity": 1}
{"task_id": "codeeval-43", "problem": "Create a Python Sequence class named 'Sentence' which can be instantiated with a string of words. Implement the required special method to follow the Sequence protocol", "topic": "typing", "object": "class", "name": "Sentence", "canonical_solution": "class Sentence:\n    def __init__(self, sentence):\n        self.words = sentence.split()\n        \n    def __getitem__(self, index):\n        return self.words[index]\n    \n    def __len__(self):\n        return len(self.words)", "tests": "[{'ctx': 'obj = cls(\"A quick brown fox\")', 'assertion': 'list(obj) == [\"A\",\"quick\",\"brown\",\"fox\"]'},  {'ctx': 'obj = cls(\"A quick brown fox\")', 'assertion': 'obj[2] == \"brown\"'},  {'ctx': 'obj = cls(\"\")', 'assertion': 'len(obj) == 0'}]", "complexity": 3}
{"task_id": "codeeval-44", "problem": "Create a Python class named 'Coordinate' that represents a latitude and longitude of a geagraphical coordinate and implement a method such that two objects having the same coordinate returns true when compared with == operator", "topic": "special method", "object": "class", "name": "Coordinate", "canonical_solution": "class Coordinate:\n    def __init__(self, latitude, longitude):\n        self.latitude = latitude\n        self.longitude = longitude\n    \n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.latitude == other.latitude and self.longitude == other.longitude\n        return False", "tests": "[{'ctx': 'obj1 = cls(37.77, -122.41)\\nobj2 = cls(34.05, -118.24)', 'assertion': 'obj1 != obj2'},  {'ctx': 'obj1 = cls(37.77, -122.41)\\nobj2 = cls(37.77, -122.41)', 'assertion': 'obj1 == obj2'}, {'ctx': 'obj1 = cls(37.77, -122.41)\\nobj2 = (37.77, -122.41)', 'assertion': 'obj1 != obj2'} ]", "complexity": 1}
{"task_id": "codeeval-45", "problem": "Create a Python class named 'Vector3d' that represents a three dimensional vector. The class can be instantiated with three positional arguments representing x, y and z component of the vector. Implement __format__ method such that it's formatted string representation displays the instance variables and their values, as floats with double precision, separated by a colon in parenthesis", "topic": "pythonic object", "object": "class", "name": "Vector3d", "canonical_solution": "class Vector3d:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n    \n    def __format__(self, format_spec):\n        return '({:.2f}:{:.2f}:{:.2f})'.format(self.x, self.y, self.z)", "tests": "[{'ctx': 'obj = cls(1, 2, 3)', 'assertion': 'obj.x == 1 and obj.y == 2 and obj.z == 3'}, {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'}, {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2, 3, 4)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},    {'ctx': 'obj = cls(1.2345, 2.3456, -3.4567)\\ns = str(format(obj))', 'assertion': 's == \"(1.23:2.35:-3.46)\"'}]", "complexity": 2}
{"task_id": "codeeval-46", "problem": "Write a Python function named 'reverse_string' that reverses a given string", "topic": "slicing", "object": "function", "name": "reverse_string", "canonical_solution": "def reverse_string(string):\n    return string[::-1]", "tests": "[{'assertion': 'func(\"hello\") == \"olleh\"'}, {'assertion': 'func(\"Hello World\") == \"dlroW olleH\"'}, {'assertion': 'func(\"\") == \"\"'}, {'assertion': 'func(\"12345\") == \"54321\"'},{'assertion': 'func(\"llo\") == \"oll\"'}, {'assertion': 'func(\"elo\") == \"ole\"'}, {'assertion': 'func(\"helloel\") == \"leolleh\"'}, {'assertion': 'func(\"hello\") == \"olleh\"'}, {'assertion': 'func(\"hell\") == \"lleh\"'}, {'assertion': 'func(\"hellolo\") == \"ololleh\"'}, {'assertion': 'func(\"hel\") == \"leh\"'}, {'assertion': 'func(\"Hello Worldo Worl\") == \"lroW odlroW olleH\"'}, {'assertion': 'func(\"HWorld\") == \"dlroWH\"'}, {'assertion': 'func(\"Hello Wor\") == \"roW olleH\"'}, {'assertion': 'func(\"Hello World\") == \"dlroW olleH\"'}, {'assertion': 'func(\"Hello WorldWor\") == \"roWdlroW olleH\"'}, {'assertion': 'func(\"Helrldorld\") == \"dlrodlrleH\"'}, {'assertion': 'func(\"Hello Worldo W\") == \"W odlroW olleH\"'}, {'assertion': 'func(\"51525354555\") == \"55545352515\"'}, {'assertion': 'func(\"1234512345\") == \"5432154321\"'}, {'assertion': 'func(\"12345\") == \"54321\"'}, {'assertion': 'func(\"5\") == \"5\"'}, {'assertion': 'func(\"1125\") == \"5211\"'}, {'assertion': 'func(\"12341234\") == \"43214321\"'}, {'assertion': 'func(\"12112212312412512\") == \"21521421321221121\"'}, {'assertion': 'func(\"234545\") == \"545432\"'}]", "complexity": 1}
{"task_id": "codeeval-47", "problem": "Create a Python class named 'Vector' that represents a vector of any dimension, and can be instantiated with an iterable. Implement the required special method such that the class supports instance variable retrieval by index and slice which returns the same object", "topic": "special method", "object": "class", "name": "Vector", "canonical_solution": "class Vector:\n    def __init__(self, iterable):\n        self.data = list(iterable)\n    \n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self.data[key]\n        elif isinstance(key, slice):\n            return Vector(self.data[key])\n        else:\n            raise TypeError('Invalid key type')", "tests": "[{'ctx': 'obj = cls([1, 2, 3, 4, 5])', 'assertion': 'list(obj[:]) == [1, 2, 3, 4, 5]'},    {'ctx': 'obj = cls([1, 2, 3, 4, 5])', 'assertion': 'list(obj[1:3]) == [2, 3]'},     {'ctx': 'obj = cls([1, 2, 3, 4, 5])', 'assertion': 'obj[3] == 4'} ]", "complexity": 2}
{"task_id": "codeeval-48", "problem": "Write an efficient Python function named 'fibonacci' with caching that returns the given nth number in the fibonacci series", "topic": "decorator", "object": "function", "name": "fibonacci", "canonical_solution": "from functools import lru_cache\n@lru_cache(maxsize=None)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)", "tests": "[{'assertion': 'func(35) == 9227465'}, {'ctx': 'import time\\ndef slow_fibonacci(n):\\n    if n < 2:\\n        return n\\n    return fibonacci(n - 1) + fibonacci(n - 2)\\nstart_time = time.time()\\nslow_fibonacci(40)\\nrun_time_slow_fib = time.time() - start_time\\nstart_time = time.time()\\nfunc(40)\\nrun_time_fast_fib = time.time() - start_time', 'assertion': 'run_time_slow_fib - run_time_fast_fib > 0'},{'assertion': 'func(34) == 5702887'}, {'assertion': 'func(35) == 9227465'}, {'assertion': 'func(36) == 14930352'}]", "complexity": 3}
{"task_id": "codeeval-49", "problem": "Create a Python class named 'RandomElement' whose instance can be built from any iterable, and stores an internal list from the given iterable. The instantiated object is callable which returns a random element from its internal list", "topic": "functional programming", "object": "class", "name": "RandomElement", "canonical_solution": "import random\n\nclass RandomElement:\n    def __init__(self, iterable):\n        self.internal_list = list(iterable)\n        \n    def __call__(self):\n        return random.choice(self.internal_list)", "tests": "[{'ctx': 'obj1 = cls([])', 'assertion': 'callable(obj1) == True'},  {'ctx': 'obj1 = cls([10, 20, 30, 40, 50])\\nr = obj1()', 'assertion': 'r in [10, 20, 30, 40, 50]'},  {'ctx': 'obj1 = cls(\"Hello World\")\\nr = obj1()', 'assertion': 'r in list(\"Hello World\")'}]", "complexity": 2}
{"task_id": "codeeval-50", "problem": "Write a Python function named 'create_deque' that returns a Python data structure to support frequent operation of insertion and removal from both ends of a sequence", "topic": "data structure", "object": "function", "name": "create_deque", "canonical_solution": "from collections import deque\n\ndef create_deque():\n    return deque()", "tests": "[{'ctx': 'dq = func()', 'assertion': 'len(dq) == 0'},  {'ctx': 'dq = func()', 'assertion': 'isinstance(dq, deque) == True'}, {'ctx': 'dq = func()\\ndq.append(20)\\ndq.appendleft(10)', 'assertion': 'dq[0] == 10 and dq[1] == 20'},  {'ctx': 'dq = func()\\ndq.append(20)\\ndq.appendleft(10)\\nr = dq.popleft()', 'assertion': 'r == 10 and len(dq) == 1'}, {'ctx': 'dq = func()\\ndq.append(20)\\ndq.appendleft(10)\\nr = dq.pop()', 'assertion': 'r == 20 and len(dq) == 1'} ]", "complexity": 2}
{"task_id": "codeeval-51", "problem": "Write a Python function named 'get_last_inserted_key' that returns the value of the last key that was inserted in the given dictionary", "topic": "dictionary", "object": "function", "name": "get_last_inserted_key", "canonical_solution": "def get_last_inserted_key(dictionary):\n    keys = list(dictionary.keys())\n    if len(keys) > 0:\n        last_inserted_key = keys[-1]\n        return dictionary[last_inserted_key]", "tests": "[{'assertion': 'func({1: \"a\", 2: \"b\", 3: \"c\"}) == \"c\"'}, {'assertion': 'func({1: \"a\", 2: \"b\", 3: {\"a\": 1, \"b\": 2, \"c\": 3}}) == {\"a\": 1, \"b\": 2, \"c\": 3}'}, {'assertion': 'func({\"a\": 1, \"b\": 2, \"c\": 3}) == 3'}, {'assertion': 'func({}) == None'}, {'assertion': 'func({\"a\": 1}) == 1'}, {'ctx': 'd = {1: 100, 2: 200, 3: 300}\\nr = func(d)', 'assertion': 'd == {1: 100, 2: 200, 3: 300}'},{'assertion': 'func({}) == None'}, {'assertion': 'func({}) == None'}, {'assertion': 'func({}) == None'}]", "complexity": 1}
{"task_id": "codeeval-52", "problem": "Write an awaitable Python function named 'process_single_sentence' that takes a string as sentence and its location index int in a paragraph, and returns a dictionary of location index and the number of words in the sentence. Create another awaitable function named 'process_many_sentences' that given a list of string calls the awaitable process_single_sentence for each sentence in the list. The function records the individual result from each awaitable into a file named 'results.json' as they are completed. The saving of the file task should be delegated to a thread", "topic": "concurrency", "object": "function", "name": "process_many_sentences", "canonical_solution": "import asyncio\nimport concurrent.futures\nimport json\n\nasync def process_single_sentence(sentence, index):\n    num_words = len(sentence.split())\n    return {index: num_words}\n\ndef save_to_file(result):\n    with open('results.json', 'a') as f:\n        json.dump(result, f)\n        f.write('\\n')\n\nasync def process_many_sentences(sentences):\n    tasks = [process_single_sentence(sentence, index) for index, sentence in enumerate(sentences)]\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        for future in asyncio.as_completed(tasks):\n            result = await future\n            executor.submit(save_to_file, result)", "tests": "[{'ctx': 'from collections import abc\\nsentences = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\ncoro = func(sentences)', 'assertion': 'isinstance(coro, abc.Coroutine) == True'}, {'keyword': 'asyncio.as_completed'}, {'keyword': 'submit'}]", "complexity": 3}
{"task_id": "codeeval-53", "problem": "Write a Python function named 'get_mro' that returns a list of method resolution order of a given class", "topic": "inheritance", "object": "function", "name": "get_mro", "canonical_solution": "def get_mro(cls):\n    return cls.mro()", "tests": "[{'ctx': 'class A:\\n    pass\\n\\nclass B(A):\\n    pass\\n\\nclass C(A):\\n    pass\\n\\nclass D(B, C):\\n    pass\\n\\nmro = get_mro(D)\\nr = [c.__name__ for c in mro]', 'assertion': 'r == [\"D\", \"B\", \"C\", \"A\", \"object\"]'}]", "complexity": 2}
{"task_id": "codeeval-54", "problem": "Create a Python class named 'Vector3d' that represents a three dimensional vector. The class can be instantiated with three positional arguments representing x, y and z component of the vector. Implement the required special method to make the objects of Vector3d class hashable", "topic": "pythonic object", "object": "class", "name": "Vector3d", "canonical_solution": "class Vector3d:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __hash__(self):\n        return hash((self.x, self.y, self.z))\n\n    def __eq__(self, other):\n        return isinstance(other, Vector3d) and self.x == other.x and self.y == other.y and self.z == other.z", "tests": "[{'ctx': 'obj = cls(1, 2, 3)', 'assertion': 'obj.x == 1 and obj.y == 2 and obj.z == 3'},   {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},   {'ctx': 'error = False\\ntry:\\n    obj = cls(1, 2, 3, 4)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},      {'ctx': 'obj1 = cls(10, 20, 30)\\nobj2 = cls(10, 20, 30)', 'assertion': 'hash(obj1) == hash(obj2)'},  {'ctx': 'obj1 = cls(10, 20, 30)\\nobj2 = cls(1, 2, 3)', 'assertion': 'hash(obj1) != hash(obj2)'} ]", "complexity": 2}
{"task_id": "codeeval-55", "problem": "Create a Python generator class named 'Sentence' which can be instantiated with a string of words. Implement the required special method that will allow generating one word at a time in the given sentence", "topic": "generator", "object": "class", "name": "Sentence", "canonical_solution": "class Sentence:\n    def __init__(self, sentence):\n        self.words = sentence.split()\n\n    def __iter__(self):\n        for word in self.words:\n            yield word", "tests": "[{'ctx': 'obj = cls(\"A quick brown fox\")', 'assertion': 'list(obj) == [\"A\",\"quick\",\"brown\",\"fox\"]'},    {'ctx': 'obj = cls(\"A quick brown fox\")\\ntry:\\n    next(obj)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'},    {'ctx': 'obj = cls(\"\")\\nerror = False\\ntry:\\n    len(obj)\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'}, {'ctx': 'obj = cls(\"\")\\nerror = False\\ntry:\\n    obj[1]\\nexcept TypeError:\\n    error = True', 'assertion': 'error == True'} ]", "complexity": 3}
{"task_id": "codeeval-56", "problem": "Write a Python function named 'create_float_array' that returns a Python data structure to support memory efficient operation on a sequence of double precision floating point numbers", "topic": "data structure", "object": "function", "name": "create_float_array", "canonical_solution": "import array\n\ndef create_float_array(numbers):\n    return array.array('d', numbers)", "tests": "[{'ctx': 'import array\\nnumbers = [1.0, 2.0, 3.0]\\nresult = func(numbers)', 'assertion': 'result == array.array(\"d\", [1.0, 2.0, 3.0])'}]", "complexity": 2}
{"task_id": "codeeval-57", "problem": "Create a Python generator function named 'reverse_words' that yields each word of a given sentence in reverse order", "topic": "generator", "object": "function", "name": "reverse_words", "canonical_solution": "def reverse_words(sentence):\n    words = sentence.split()  # Split the sentence into a list of words\n    for word in reversed(words):\n        yield word", "tests": "[{'ctx': 'gen = func(\"A quick brown fox\")', 'assertion': 'list(gen) == [\"fox\",\"brown\",\"quick\",\"A\"]'}, {'ctx': 'gen = func(\"\")', 'assertion': 'list(gen) == []'}, {'ctx': 'gen = func(\"A quick brown fox\")\\nwords = [w for w in gen]', 'assertion': 'words == [\"fox\",\"brown\",\"quick\",\"A\"]'}]", "complexity": 2}
{"task_id": "codeeval-58", "problem": "Create a context manager Python function named 'decimal_context' that sets the precision of the decimal context to 8", "topic": "context manager", "object": "function", "name": "decimal_context", "canonical_solution": "import decimal\nfrom contextlib import contextmanager\n\n@contextmanager\ndef decimal_context(precision):\n    previous_precision = decimal.getcontext().prec\n    decimal.getcontext().prec = precision\n    try:\n        yield\n    finally:\n        decimal.getcontext().prec = previous_precision", "tests": "[{'ctx': 'original_precision = decimal.getcontext().prec\\nwith decimal_context(precision=8):\\n    changed_precision = decimal.getcontext().prec', 'assertion': 'changed_precision == 8 and original_precision == decimal.getcontext().prec'}, {'ctx': 'with decimal_context(precision=8):\\n    r = decimal.Decimal(1)/decimal.Decimal(3)', 'assertion': 'r == decimal.Decimal(\"0.33333333\")'}]", "complexity": 2}
{"task_id": "codeeval-59", "problem": "Write an awaitable Python function named 'count_words' that takes a long text and returns a generator of dictionary with keys as words in the text and values as the number of times the key appeared in the given text", "topic": "concurrency", "object": "function", "name": "count_words", "canonical_solution": "import asyncio\nfrom collections import Counter\n\nasync def count_words(text):\n    words = text.split()\n    word_counts = Counter(words)\n\n    for word, count in word_counts.items():\n        yield {word: count}\n        await asyncio.sleep(0.01) # Simulate async I/O", "tests": "[{'ctx': 'from collections import abc\\ntxt = \"lorem ipsum dolor sit amet dolor ipsum\"\\ngen = func(txt)', 'assertion': 'isinstance(gen, abc.AsyncGenerator) == True'}, {'ctx': 'txt = \"lorem ipsum dolor sit amet dolor ipsum\"\\nasync def run_count_words(text):\\n    res = [result async for result in count_words(text)]\\n    return res\\n\\nr = asyncio.run(run_count_words(txt))', 'assertion': 'r == [{\"lorem\": 1}, {\"ipsum\": 2}, {\"dolor\": 2}, {\"sit\": 1}, {\"amet\": 1}]'}]", "complexity": 2}
{"task_id": "codeeval-60", "problem": "Write a Python function named 'merge_dicts(k, d)' that returns a dictionary from given lists of keys k and dictionaries d", "topic": "dictionary", "object": "function", "name": "merge_dicts", "canonical_solution": "def merge_dicts(keys, dicts):\n    result = {}\n    for key, d in zip(keys, dicts):\n        result[key] = d\n    return result", "tests": "[{'assertion': 'func([\"a\", \"b\"], [{\"name\": \"John\"}, {\"age\": 30}]) == {\"a\": {\"name\": \"John\"}, \"b\": {\"age\": 30}}'},  {'assertion': 'func([\"a\", \"b\", \"c\"], [{\"name\": \"John\"}, {\"age\": 30}]) == {\"a\": {\"name\": \"John\"}, \"b\": {\"age\": 30}}'},  {'assertion': 'func([\"a\", \"a\", \"b\"], [{\"name\": \"John\"}, {\"age\": 30}, {\"address\": \"New York\"}]) == {\"a\": {\"age\": 30}, \"b\": {\"address\": \"New York\"}}'},  {'assertion': 'func([], []) == {}'}]", "complexity": 1}
{"task_id": "codeeval-61", "problem": "Write a Python function named 'find_largest_n_elements(nums, n)' that returns the largest given n elements of the given list of numbers nums", "topic": "sorting", "object": "function", "name": "find_largest_n_elements", "canonical_solution": "def find_largest_n_elements(numbers, n):\n    # Sort the list of numbers in descending order\n    sorted_numbers = sorted(numbers, reverse=True)\n    # Return the first n elements of the sorted list\n    return sorted_numbers[:n]", "tests": "[{'assertion': 'func([1, 2, 3, 4, 5], 10) == [5, 4, 3, 2, 1]'},  {'assertion': 'func([1, 2, 3, 4, 5], 2) == [5, 4]'},  {'assertion': 'func([1, 2, 3, 4, 5], 5) == [5, 4, 3, 2, 1]'},  {'assertion': 'func([], 2) == []'},  {'assertion': 'func([1, 2, 3, -4, -5], 10) == [3, 2, 1, -4, -5]'} ]", "complexity": 1}
{"task_id": "codeeval-62", "problem": "Write a Python function named 'create_dict' that returns a dictionary from a given list of two element tuples where the first element is key and the second element the value", "topic": "dictionary", "object": "function", "name": "create_dict", "canonical_solution": "def create_dict(lst):\n    return {k: v for k, v in lst}", "tests": "[{'assertion': 'func([(\"a\", 1), (\"b\", 2), (\"a\", 3)]) == {\"a\": 3, \"b\": 2}'},  {'assertion': 'func([(\"a\", 1), (\"b\", 2), (\"c\", 3)]) == {\"a\": 1, \"b\": 2, \"c\": 3}'}, {'assertion': 'func([(\"a\", 1)]) == {\"a\": 1}'},  {'assertion': 'func([(\"a\", 1), (3.14, \"pi\"), (True, [1, 2, 3])]) == {\"a\": 1, 3.14: \"pi\", True: [1, 2, 3]}'}, {'assertion': 'func([]) == {}'}]", "complexity": 1}
{"task_id": "codeeval-63", "problem": "Create a Python function named 'count_element(lst, e)' that returns the number of times a given element e appears in a given list lst", "topic": "list", "object": "function", "name": "count_element", "canonical_solution": "from collections import Counter\ndef count_element(lst, element):\n    counter = Counter(lst)\n    return counter[element]", "tests": "[{'assertion': 'func([1, 1, 2, 3, 4, 1, 4], 1) == 3'}, {'assertion': 'func([\"a\", \"b\", \"c\", \"a\", \"a\", \"d\"], \"a\") == 3'}, {'assertion': 'func([1, 2, 3, 4, 5, 6], 7) == 0'}, {'assertion': 'func([], 10) == 0'}]", "complexity": 1}
{"task_id": "codeeval-64", "problem": "Create a Python class named 'Vector2D' that represents a two dimensional vector with components named as 'x' and 'y', and implement a method to support vector addition that overloads the '+' operator", "topic": "special method", "object": "class", "name": "Vector2D", "canonical_solution": "class Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        return Vector2D(self.x + other.x, self.y + other.y)", "tests": "[{'ctx': 'obj1 = cls(1, 2)\\nobj2 = cls(3, 4)\\nobj3 = obj1 + obj2', 'assertion': 'obj3.x == 4  and obj3.y == 6'}, {'ctx': 'obj1 = cls(2,3)', 'assertion': 'obj1.x == 2 and obj1.y == 3'}]", "complexity": 2}
{"task_id": "codeeval-65", "problem": "Write a Python function named 'get_num_vowels' that returns a number of vowels present in a given string. Write another multi-threadeded function named 'get_vowels_in_text' that takes a very long text and returns a list of number of vowels present in each word in the text", "topic": "concurrency", "object": "function", "name": "get_vowels_in_text", "canonical_solution": "from concurrent import futures\n\ndef get_num_vowels(word):\n    return len([char for char in word if char.lower() in 'aeiou'])\n\ndef get_vowels_in_text(text):\n    words = text.split()\n\n    with futures.ThreadPoolExecutor() as executor:\n        results = list(executor.map(get_num_vowels, words))\n\n    return results", "tests": "[{'ctx': 'text = \"The quick brown fox jumps over the lazy dog\"\\nr = func(text)', 'assertion': 'r == [1, 2, 1, 1, 1, 2, 1, 1, 1]'}, {'keyword': 'ThreadPoolExecutor'}]", "complexity": 3}
{"task_id": "codeeval-66", "problem": "Create a context manager Python class named 'DecimalContext' that sets the precision of the decimal context to the user defined value", "topic": "context manager", "object": "class", "name": "DecimalContext", "canonical_solution": "import decimal\n\nclass DecimalContext:\n    def __init__(self, precision):\n        self.original_precision = decimal.getcontext().prec\n        self.precision = precision\n\n    def __enter__(self):\n        decimal.getcontext().prec = self.precision\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        decimal.getcontext().prec = self.original_precision", "tests": "[{'ctx': 'original_precision = decimal.getcontext().prec\\nwith cls(precision=8):\\n    changed_precision = decimal.getcontext().prec', 'assertion': 'changed_precision == 8 and original_precision == decimal.getcontext().prec'}, {'ctx': 'with cls(precision=8):\\n    r = decimal.Decimal(1)/decimal.Decimal(3)', 'assertion': 'r == decimal.Decimal(\"0.33333333\")'}]", "complexity": 2}
{"task_id": "codeeval-67", "problem": "Write a Python function named 'deduplicate_list' that returns a de-duplicated list from a given list while preserving the order of the original list", "topic": "set", "object": "function", "name": "deduplicate_list", "canonical_solution": "def deduplicate_list(lst):\n    deduplicated_lst = []\n    seen = set()\n    \n    for ele in lst:\n        if ele not in seen:\n            deduplicated_lst.append(ele)\n            seen.add(ele)\n    \n    return deduplicated_lst", "tests": "[{'assertion': 'func([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]'},  {'assertion': 'func([1, 2, 3, 2, 4, 1, 5, 3, 4]) == [1, 2, 3, 4, 5]'},  {'assertion': 'func([1, 1, 1, 1, 1, 1]) == [1]'},  {'assertion': 'func([\"a\", \"a\", \"b\", \"b\"]) == [\"a\", \"b\"]'}, {'assertion': 'func([]) == []'},{'assertion': 'func([1, 3, 4, 5, 4, 4]) == [1, 3, 4, 5]'}, {'assertion': 'func([1, 2, 3, 2, 4, 4, 4, 6, 5]) == [1, 2, 3, 4, 6, 5]'}, {'assertion': 'func([1, 2, -1, 0, 2, 1, 2]) == [1, 2, -1, 0]'}, {'assertion': \"func(['a', 'b', 'b', 'a']) == ['a', 'b']\"}]", "complexity": 1}
{"task_id": "codeeval-68", "problem": "Write a Python function named 'check_division_equality' that takes four numbers. The function checks without loss of precision whether the division of the first two numbers is equal to the division of the last two numbers", "topic": "float", "object": "function", "name": "check_division_equality", "canonical_solution": "from decimal import Decimal, InvalidOperation\n\ndef check_division_equality(a, b, c, d):\n    try:\n        division1 = Decimal(a) / Decimal(b)\n        division2 = Decimal(c) / Decimal(d)\n        return division1 == division2\n    except InvalidOperation:\n        return False", "tests": "[{'assertion': 'func(10, 3, 20, 6) == True'}, {'assertion': 'func(10, 3, 11, 7) == False'}]", "complexity": 2}
{"task_id": "codeeval-69", "problem": "Create a Python class named 'Rectangle' that can be instantiated by length and width of a rectangle object. Implement its '__repr__' method such that it's string representation includes the class name with all it's field values in parenthesis", "topic": "pythonic object", "object": "class", "name": "Rectangle", "canonical_solution": "class Rectangle:\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n    \n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.length}, {self.width})'", "tests": "[{'ctx': 'rect = cls(10, 20)\\nr = f\"{rect}\"', 'assertion': 'r == \"Rectangle(10, 20)\"'}]", "complexity": 2}
{"task_id": "codeeval-70", "problem": "Create a Python class named 'Vector2d' that represents a two dimensional vector. The class can be instantiated with two positional arguments representing x and y components of the vector. Implement required special methods such that scalar multiplication of the Vector2d objects is supported in both forward and reverse order", "topic": "operator overloading", "object": "class", "name": "Vector2d", "canonical_solution": "class Vector2d:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __mul__(self, scalar):\n        if isinstance(scalar, (int, float)):\n            return Vector2d(self.x * scalar, self.y * scalar)\n\n    def __rmul__(self, scalar):\n        return self.__mul__(scalar)", "tests": "[{'ctx': 'v1 = cls(2, 3)\\nv2 = v1 * 2', 'assertion': 'v2.x == 4 and v2.y == 6'},  {'ctx': 'v1 = cls(2, 3)\\nv2 = 2 * v1', 'assertion': 'v2.x == 4 and v2.y == 6'}]", "complexity": 2}
{"task_id": "codeeval-71", "problem": "Write a Python function named 'get_last_element' that returns the last element of the given generator object", "topic": "generator", "object": "function", "name": "get_last_element", "canonical_solution": "def get_last_element(genObj):\n    last_element = None\n    for element in genObj:\n        last_element = element\n    return last_element", "tests": "[{'ctx': 'gen_obj = (i for i in range(5))\\nr = func(gen_obj)', 'assertion': 'r == 4'},  {'ctx': 'gen_obj = (c for c in \"hello\")\\nr = func(gen_obj)', 'assertion': 'r == \"o\"'}, {'ctx': 'gen_obj = ()\\nr = func(gen_obj)', 'assertion': 'r == None'}]", "complexity": 1}
{"task_id": "codeeval-72", "problem": "Write a Python function named 'every_other_element' that returns a shallow-copied list containing every other element of the given list", "topic": "slicing", "object": "function", "name": "every_other_element", "canonical_solution": "def every_other_element(lst):\n    return lst[::2]", "tests": "[{'assertion': 'func([1, 2, 3, 4, 5, 6]) == [1,3,5]'},  {'assertion': 'func([1, 2, 3, 4, 5, 6, 7]) == [1,3,5,7]'},  {'assertion': 'func([1]) == [1]'},  {'assertion': 'func([]) == []'}, {'ctx': 'l1 = [1,2, [3,4]]\\nl2 = func(l1)\\nl1[2].append(5)', 'assertion': 'l2 == [1, [3,4,5]]'},{'assertion': 'func([2, 2, 3, 3, 5, 6, 2, 3, 4, 3]) == [2, 3, 5, 2, 4]'}, {'assertion': 'func([2, 3, 4, 5, 5, 5, 6, 8, 9, 8, 8]) == [2, 4, 5, 6, 9, 8]'}, {'assertion': 'func([1, 0, 1, 2, 2, 2, 1, 2]) == [1, 1, 2, 1]'}]", "complexity": 1}
{"task_id": "codeeval-73", "problem": "Write a Python function named 'sort_by_length' that sorts in-place a given list of string by its length", "topic": "sorting", "object": "function", "name": "sort_by_length", "canonical_solution": "def sort_by_length(strings):\n    strings.sort(key=lambda s: len(s))", "tests": "[{'ctx': 's = []\\nfunc(s)', 'assertion': 's == []'}, {'ctx': 's = [\"apple\"]\\nfunc(s)', 'assertion': 's == [\"apple\"]'},   {'ctx': 's = [\"banana\", \"apple\", \"orange\", \"kiwi\"]\\nfunc(s)', 'assertion': 's == [\"kiwi\", \"apple\", \"banana\", \"orange\"]'},   {'ctx': 's = [\"cat\", \"dog\", \"bat\"]\\nfunc(s)', 'assertion': 's == [\"cat\", \"dog\", \"bat\"]'},  {'ctx': 's = [\"banana\", \"apple\", \"orange\", \"kiwi\"]\\nfunc(s)', 'assertion': 's == [\"kiwi\", \"apple\", \"banana\", \"orange\"]'}]", "complexity": 1}
{"task_id": "codeeval-74", "problem": "Write a Python function named 'deep_copy_list' that returns a deep copy of the given list", "topic": "object identity", "object": "function", "name": "deep_copy_list", "canonical_solution": "import copy\n\ndef deep_copy_list(original_list):\n    return copy.deepcopy(original_list)", "tests": "[{'ctx': 'l1 = [1, 2, [3, 4]]\\nl2=func(l1)\\nl2[2].append(5)', 'assertion': 'l1 == [1, 2, [3, 4]] and l2 == [1, 2, [3, 4, 5]]'}, {'ctx': 'l1 = [1, 2, [3, 4]]\\nl2=func(l1)\\nl1[2].append(5)', 'assertion': 'l1 == [1, 2, [3, 4, 5]] and l2 == [1, 2, [3, 4]]'}, {'ctx': 'l1 = [1, 2, 3]\\nl2=func(l1)\\nl2.append(4)', 'assertion': 'l1 == [1, 2, 3] and l2 == [1, 2, 3, 4]'},  {'ctx': 'l1 = [1, 2, 3]\\nl2=func(l1)','assertion': 'l1 == l2 and l1 is not l2'},  {'assertion': 'func([]) == []'}]", "complexity": 1}
{"task_id": "codeeval-75", "problem": "Write an awaitable Python function named 'process_single_sentence' that takes a string as sentence and its location index int in a paragraph, and returns a dictionary of location index and the number of words in the sentence. Create an asynchronous generator function named 'process_many_sentences' that given a list of string calls the awaitable process_single_sentence for each sentence in the list. The function yields results from awaitables in the order as they were completed", "topic": "concurrency", "object": "function", "name": "process_many_sentences", "canonical_solution": "import asyncio\n\nasync def process_single_sentence(sentence, index):\n    num_words = len(sentence.split())\n    return {index: num_words}\n\nasync def process_many_sentences(sentences):\n    tasks = [process_single_sentence(sentence, index) for index, sentence in enumerate(sentences)]\n    for future in asyncio.as_completed(tasks):\n        yield await future", "tests": "[{'ctx': 'from collections import abc\\nsentences = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\nagen = func(sentences)', 'assertion': 'isinstance(agen, abc.AsyncGenerator) == True'}, {'ctx': 'input = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\nasync def run_func(func, sentences):\\n    res = [result async for result in func(sentences)]\\n    return res\\n\\nr = asyncio.run(run_func(func, input))', 'assertion': 'sorted(r, key=lambda x: list(x.keys())[0]) == [{0: 4}, {1: 3}, {2: 4}]'}, {'keyword': 'asyncio.as_completed'}]", "complexity": 3}
{"task_id": "codeeval-76", "problem": "Create a Python generator function named 'running_sum' that takes a list of numbers and yields a running sum of the given list", "topic": "generator", "object": "function", "name": "running_sum", "canonical_solution": "def running_sum(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n        yield total", "tests": "[{'ctx': 'gen = func([1, 2, 3, 4, 5])\\nr = list(gen)', 'assertion': 'r == [1, 3, 6, 10, 15]'}, {'ctx': 'gen = func([])\\nerror = False\\ntry:\\n    next(gen)\\nexcept StopIteration:\\n    error = True', 'assertion': 'error == True'}, {'ctx': 'gen = func([5])\\nr = list(gen)', 'assertion': 'r == [5]'}, {'ctx': 'roll_sum = [r for r in func([1, -2, 3, -4, 5])]', 'assertion': 'roll_sum == [1, -1, 2, -2, 3]'}]", "complexity": 2}
{"task_id": "codeeval-77", "problem": "Create a Python class named 'Vector2d' that represents a two dimensional vector. The class can be instantiated with two positional arguments representing x and y components of the vector. Implement required special methods such that '+=' operation is supported", "topic": "operator overloading", "object": "class", "name": "Vector2d", "canonical_solution": "class Vector2d:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self", "tests": "[{'ctx': 'v1 = cls(2, 3)\\nv2 = cls(1, 6)\\nerror = False\\ntry:\\n    v1 += v2\\nexcept TypeError:\\n    error = True    ', 'assertion': 'error == False and v1.x == 3 and v1.y == 9'}]", "complexity": 2}
{"task_id": "codeeval-78", "problem": "Create a Python class named 'User' that holds two instance attributes - 'name' of type str and 'handle' of type str. Implement the class such that an object being instantiated with a handle already been used by other instance raises a 'ValueError'", "topic": "dataclass", "object": "class", "name": "User", "canonical_solution": "class User:\n    instances = []\n\n    def __init__(self, name, handle):\n        self.name = name\n        if handle in [user.handle for user in User.instances]:\n            raise ValueError('Handle already used by another user.')\n        self.handle = handle\n        User.instances.append(self)", "tests": "[{'ctx': 'error = False\\nobj1 = cls(\"John\", \"@john\")\\ntry:\\n    obj2 = cls(\"Johnathan\", \"@john1\")\\nexcept ValueError:\\n    error = True', 'assertion': 'error == False'},  {'ctx': 'error = False\\nobj3 = cls(\"Jack\", \"@jak\")\\ntry:\\n    obj4 = cls(\"Jockson\", \"@jak\")\\nexcept ValueError:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 2}
{"task_id": "codeeval-79", "problem": "Write a Python function named 'merge_dictionaries' that takes two dictionaries and returns a new dictionary. Add the key-value pairs from the second dictionary to the first while keeping the common keys' value of the first dictionary", "topic": "dictionary", "object": "function", "name": "merge_dictionaries", "canonical_solution": "def merge_dictionaries(dict1, dict2):\n    new_dict = dict1.copy()\n    new_dict.update(dict2)\n    # bring the original dict1 values back for common keys\n    new_dict.update(dict1)\n    return new_dict", "tests": "[{'assertion': 'func({\"a\": 1, \"b\": 2, \"c\": 3}, {\"b\": 4, \"d\": 5}) == {\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 5}'}, {'assertion': 'func({}, {}) == {}'}, {'assertion': 'func({\"a\": 1, \"b\": 2, \"c\": 3}, {}) == {\"a\": 1, \"b\": 2, \"c\": 3}'}, {'assertion': 'func({}, {\"a\": 1, \"b\": 2, \"c\": 3}) == {\"a\": 1, \"b\": 2, \"c\": 3}'}]", "complexity": 1}
{"task_id": "codeeval-80", "problem": "Write an awaitable Python function named 'process_single_sentence' that takes a string as sentence and its location index int in a paragraph, and returns a dictionary of location index and the number of words in the sentence. Create another awaitable function named 'process_many_sentences' that given a list of string calls the awaitable process_single_sentence for each sentence in the list. The function returns all results when all awaitables are done", "topic": "concurrency", "object": "function", "name": "process_many_sentences", "canonical_solution": "import asyncio\n\nasync def process_single_sentence(sentence, index):\n    num_words = len(sentence.split())\n    return {index: num_words}\n\nasync def process_many_sentences(sentences):\n    tasks = [process_single_sentence(sentence, index) for index, sentence in enumerate(sentences)]\n    results = await asyncio.gather(*tasks)\n    return results", "tests": "[{'ctx': 'from collections import abc\\nsentences = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\ncoro = func(sentences)', 'assertion': 'isinstance(coro, abc.Coroutine) == True'}, {'ctx': 'sentences = [\"This is a sentence.\", \"Another sentence here.\", \"And one more sentence.\"]\\nr = asyncio.run(func(sentences))', 'assertion': 'r == [{0: 4}, {1: 3}, {2: 4}]'}]", "complexity": 3}
{"task_id": "codeeval-81", "problem": "Write a Python function named 'multiply_numbers' that returns the multiplication of all numbers in the given list. The function returns None for empty list", "topic": "functional programming", "object": "function", "name": "multiply_numbers", "canonical_solution": "from functools import reduce\nimport operator\ndef multiply_numbers(lst):\n    if lst:\n        return reduce(operator.mul, lst)", "tests": "[{'assertion': 'func([3,4,5]) == 60'},  {'assertion': 'func([3,4,5,0]) == 0'},  {'assertion': 'func([10]) == 10'},  {'assertion': 'func([]) == None'},{'assertion': 'func([2, 3, 2, 2, 2]) == 48'}, {'assertion': 'func([2, 4, 5, 3, 1, 5, 3]) == 1800'}, {'assertion': 'func([8, 9, 9, 8, 9, 8]) == 373248'}]", "complexity": 1}
{"task_id": "codeeval-82", "problem": "Create a Python class named 'Vector2d' that represents a two dimensional vector. The class can be instantiated with two positional arguments representing x and y components of the vector. Implement required special methods such that matrix multiplication is supported with any tuple or list of two elements in both forward and reverse order", "topic": "operator overloading", "object": "class", "name": "Vector2d", "canonical_solution": "class Vector2d:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __matmul__(self, other):\n        if isinstance(other, self.__class__):\n            return self.x * other.x + self.y * other.y\n        elif isinstance(other, (list, tuple)) and len(other) == 2:\n            return self.x * other[0] + self.y * other[1]\n        else:\n            raise TypeError(\"Invalid type for matmul\")\n\n    def __rmatmul__(self, other):\n        return self.__matmul__(other)", "tests": "[{'ctx': 'v1 = cls(2, 3)\\nr = v1 @ (2, 3)', 'assertion': 'r == 13'},  {'ctx': 'v1 = cls(2, 3)\\nr = (2, 3) @ v1', 'assertion': 'r == 13'}]", "complexity": 2}
{"task_id": "codeeval-83", "problem": "Create a Python generator function named 'word_generator' that yields each word of a given sentence", "topic": "generator", "object": "function", "name": "word_generator", "canonical_solution": "def word_generator(sentence):\n    words = sentence.split()\n    for word in words:\n        yield word", "tests": "[{'ctx': 'gen = func(\"A quick brown fox\")', 'assertion': 'list(gen) == [\"A\",\"quick\",\"brown\",\"fox\"]'}, {'ctx': 'gen = func(\"\")', 'assertion': 'list(gen) == []'}, {'ctx': 'gen = func(\"A quick brown fox\")\\nwords = [w for w in gen]', 'assertion': 'words == [\"A\",\"quick\",\"brown\",\"fox\"]'}]", "complexity": 1}
{"task_id": "codeeval-84", "problem": "Create a Python class named 'Vector2d' that represents a two dimensional vector. The class can be instantiated with two positional arguments representing x and y components of the vector. Implement required special methods such that '+' operation is supported", "topic": "operator overloading", "object": "class", "name": "Vector2d", "canonical_solution": "class Vector2d:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        if isinstance(other, Vector2d):\n            return Vector2d(self.x + other.x, self.y + other.y)\n        else:\n            raise TypeError('Unsupported operand in + operation')", "tests": "[{'ctx': 'v1 = cls(2, 3)\\nv2 = cls(-1, 5)\\nerror = False\\ntry:\\n    v3 = v1 + v2\\nexcept TypeError:\\n    error = True    ', 'assertion': 'error == False and v3.x == 1 and v3.y == 8'}, {'ctx': 'v1 = cls(2, 3)\\nerror = False\\ntry:\\n    v3 = v1 + 10\\nexcept TypeError:\\n    error = True    ', 'assertion': 'error == True'}]", "complexity": 2}
{"task_id": "codeeval-85", "problem": "Create a Python class named `Temperature` which can be instantiated with a temperature in Celsius. The class internally stores the temperature in Celsius and converts to/from Fahrenheit and Kelvin when needed. Implement the getter and setter methods each for Celsius, Fahrenheit, and Kelvin named `celcius`, `fahrenheit`, and `kelvin` respectively", "topic": "pythonic object", "object": "class", "name": "Temperature", "canonical_solution": "class Temperature: \n    def __init__(self, celsius=0): \n        self._celsius = celsius \n \n    @property \n    def celsius(self): \n        return self._celsius \n \n    @celsius.setter \n    def celsius(self, value): \n        self._celsius = value \n \n    @property \n    def fahrenheit(self): \n        return self._celsius * 9 / 5 + 32 \n \n    @fahrenheit.setter \n    def fahrenheit(self, value): \n        self._celsius = (value - 32) * 5 / 9 \n \n    @property \n    def kelvin(self): \n        return self._celsius + 273.15 \n \n    @kelvin.setter \n    def kelvin(self, value): \n        self._celsius = value - 273.15", "tests": "[{'ctx': 't1 = cls(25)', 'assertion': 't1.celsius == 25'}, {'ctx': 't1 = cls(25)', 'assertion': 't1.fahrenheit == 77'}, {'ctx': 't1 = cls(25)', 'assertion': 't1.kelvin == 298.15'}, {'ctx': 't1 = cls(25)\\nt1.celsius = 100', 'assertion': 't1.fahrenheit == 212'}, {'ctx': 't1 = cls(25)\\nt1.celsius = 100', 'assertion': 't1.kelvin == 373.15'}, {'ctx': 't1 = cls(25)\\nt1.fahrenheit = 212', 'assertion': 't1.celsius == 100'}, {'ctx': 't1 = cls(25)\\nt1.fahrenheit = 212', 'assertion': 't1.kelvin == 373.15'}, {'ctx': 't1 = cls(25)\\nt1.kelvin = 373.15', 'assertion': 't1.celsius == 100'}, {'ctx': 't1 = cls(25)\\nt1.kelvin = 373.15', 'assertion': 't1.fahrenheit == 212'}]", "complexity": 2}
{"task_id": "codeeval-86", "problem": "Create a Python Sequence class named `CircularList` which can be instantiated with a list. Implement the required special methods to follow the Sequence protocol. This class must act like a regular list but loops around at the end, meaning if you access an index beyond the length of the list, it should start from the beginning again", "topic": "typing", "object": "class", "name": "CircularList", "canonical_solution": "class CircularList: \n    def __init__(self, data=[]): \n        self.data = list(data) \n \n    def __len__(self): \n        return len(self.data) \n \n    def __getitem__(self, index): \n        if isinstance(index, int): \n            # Handle negative indices \n            index = index % len(self.data) \n            return self.data[index] \n        elif isinstance(index, slice): \n            # Handle slice indices \n            start, stop, step = index.indices(len(self.data)) \n            return [self[i] for i in range(start, stop, step)] \n \n    def __setitem__(self, index, value): \n        index = index % len(self.data) \n        self.data[index] = value", "tests": "[{'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[0] == 1'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[5] == 1'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[6] == 2'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[7] == 3'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[8] == 4'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[9] == 5'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[10] == 1'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[11] == 2'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[12] == 3'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[13] == 4'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[14] == 5'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[15] == 1'}, {'ctx': 'c = cls([1, 2, 3, 4, 5])', 'assertion': 'c[16] == 2'}]", "complexity": 3}
{"task_id": "codeeval-87", "problem": "Create a Python class named `BankAccount` which can be instantiated with an initial balance. If no initial balance is provided, it should default to 0. The class should implement two methods named deposit and withdraw. The deposit method should add the given amount to the balance and the withdraw method should subtract the given amount from the balance. The withdraw method should raise a custom exception named InsufficientFundsError if the amount to withdraw is greater than the current balance.", "topic": "error handling", "object": "class", "name": "BankAccount", "canonical_solution": "class InsufficientFundsError(Exception): \n    def __init__(self, message=\"Insufficient funds in the account\"): \n        self.message = message \n        super().__init__(self.message) \n \nclass BankAccount: \n    def __init__(self, initial_balance=0): \n        self.balance = initial_balance \n \n    def deposit(self, amount): \n        self.balance += amount \n \n    def withdraw(self, amount): \n        if amount > self.balance: \n            raise InsufficientFundsError() \n        self.balance -= amount","tests": "[{'ctx': 'account = cls(100)\\naccount.deposit(50)', 'assertion': 'account.balance == 150'}, {'ctx': 'account = cls(100)\\naccount.deposit(50)\\naccount.withdraw(50)', 'assertion': 'account.balance == 100'}, {'ctx': 'account = cls(100)\\nerror = False\\ntry:\\n    account.withdraw(200)\\nexcept InsufficientFundsError as e:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 1}
{"task_id": "codeeval-88", "problem": "Create a Python class named `UniqueList` which can be instantiated with a list that has unique elements. If a non-unique list is provided, the class throws a custom InstantiationError. Implement the `append` method such that only unique elements can be added to the UniqueList object. If an item already exists in the list, the append method should raise a ValueError. Implement a property method named `elements` which returns the list of elements in the UniqueList object", "topic": "error handling", "object": "class", "name": "UniqueList", "canonical_solution": "class InstantiationError(Exception):\n    pass\n\nclass UniqueList:\n    def __init__(self, initial_elements=None):\n        if initial_elements is None:\n            initial_elements = []\n\n        if len(set(initial_elements)) != len(initial_elements):\n            raise InstantiationError()\n\n        self._elements = list(initial_elements)\n\n    def append(self, item):\n        if item in self._elements:\n            raise ValueError(\"Item already exists in the list\")\n        else:\n            self._elements.append(item)\n    \n    @property\n    def elements(self):\n        return self._elements", "tests": "[{'ctx': 'error = False\\ntry:\\n    cls([1, 2, 3, 4, 5, 5])\\nexcept InstantiationError as e:\\n    error = True', 'assertion': 'error == True'}, {'ctx': 'ul = cls([1, 2, 3])\\nul.append(4)', 'assertion': 'ul.elements == [1, 2, 3, 4]'}, {'ctx': 'ul = cls([1, 2, 3])\\nerror = False\\ntry:\\n    ul.append(3)\\nexcept ValueError as e:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 2}
{"task_id": "codeeval-89", "problem": "Create a Python base class named `Pet` which can be instantiated with a str name. Create two subclasses named `Dog` and `Cat` which inherit from the base class `Pet`. Implement a static factory method named factory in the base class which returns an instance of `Dog` or `Cat` based on the `pet_type` argument. If the `pet_type` is \"dog\", the `factory` method should return an instance of Dog with the given name. If the pet_type is \"cat\", the factory method should return an instance of Cat with the given name. The factory method should raise a ValueError if the pet_type is unknown. Implement a property named name in the base class which returns the name of the pet", "topic": "design pattern", "object": "class", "name": "Pet", "canonical_solution": "class Pet: \n    def __init__(self, name): \n        self._name = name \n \n    @staticmethod \n    def factory(pet_type, name): \n        if pet_type == \"dog\": \n            return Dog(name) \n        elif pet_type == \"cat\": \n            return Cat(name) \n        raise ValueError(\"Unknown pet type\") \n    \n    @property \n    def name(self): \n        return self._name \n\nclass Dog(Pet): \n    def __init__(self, name): \n        super().__init__(name) \n\nclass Cat(Pet): \n    def __init__(self, name): \n        super().__init__(name)", "tests": "[{'ctx': 'dog = cls.factory(\"dog\", \"Buddy\")\\ncat = cls.factory(\"cat\", \"Whiskers\")', 'assertion': 'dog.name == \"Buddy\"'}, {'ctx': 'dog = cls.factory(\"dog\", \"Buddy\")\\ncat = cls.factory(\"cat\", \"Whiskers\")', 'assertion': 'cat.name == \"Whiskers\"'}, {'ctx': 'error = False\\ntry:\\n    cls.factory(\"unknown\", \"Buddy\")\\nexcept ValueError as e:\\n    error = True', 'assertion': 'error == True'}]", "complexity": 3}
{"task_id": "codeeval-90", "problem": "Create a Python class named `EmailService` which can be instantiated with no arguments. Implement a method named `send_email` which takes a message and a to_address as arguments and returns a string in the format \"message:to_address\". Create a class named `EmailClient` which can be instantiated with an instance of `EmailService`. Implement a method named `compose_and_send_email` which takes a message and a to_address as arguments, appends \" from EmailClient\" to the message and sends the email using the `EmailService` instance.", "topic": "design pattern", "object": "class", "name": "EmailService", "canonical_solution": "class EmailService: \n    def send_email(self, message, to_address): \n        return f\"{message}:{to_address}\" \n\nclass EmailClient: \n    def __init__(self, service: EmailService): \n        self.service = service \n\n    def compose_and_send_email(self, message, to_address): \n        message = message + \" from EmailClient\" \n        return self.service.send_email(message, to_address) ", "tests": "[{'ctx': 'es = cls()\\nec = EmailClient(es)\\nm = ec.compose_and_send_email(\"Hello\", \"company@mail.com\")', 'assertion': 'm == \"Hello from EmailClient:company@mail.com\"'}]", "complexity": 3}
{"task_id": "codeeval-91", "problem": "Create a Python class named `MyDate` which can be instantiated with a year, month and day. Create a class method named `from_string` which takes a date string in the format \"YYYY-MM-DD\" and returns an instance of `MyDate`. Implement a static method named `is_valid_date` which takes a date string and returns True if the date is valid and False if it is not.", "topic": "design pattern", "object": "class", "name": "MyDate", "canonical_solution": "from datetime import datetime\n\nclass MyDate:\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    @classmethod\n    def from_string(cls, date_string):\n        year, month, day = map(int, date_string.split('-'))\n        return cls(year, month, day)\n\n    @staticmethod\n    def is_valid_date(date_string):\n        try:\n            datetime.strptime(date_string, \"%Y-%m-%d\")\n            return True\n        except ValueError:\n            return False\n", "tests": "[{'ctx': 'd = MyDate(2020, 12, 31)', 'assertion': 'd.year == 2020 and d.month == 12 and d.day == 31'}, {'ctx': 'd = MyDate.from_string(\"2020-12-31\")', 'assertion': 'd.year == 2020 and d.month == 12 and d.day == 31'}, {'ctx': 'd = MyDate(2020, 12, 32)', 'assertion': 'd.is_valid_date(\"2020-12-32\") == False'}]", "complexity": 3}
{"task_id": "codeeval-92", "problem": "Create a Python class decorator named `singleton` which can be used to transform a class into a singleton. A singleton is a class that can only have one instance. If an instance of the class already exists, the decorator should return the existing instance instead of creating a new one. Create a class named `Database` and decorate it with the `Singleton` decorator. The Database class should be instantiated with a connection string and should implement a method named `connect` which returns the connection string that was used to instantiate the class.", "topic": "design pattern", "object": "function", "name": "singleton", "canonical_solution": "def singleton(cls):\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n\n    return get_instance\n\n@singleton\nclass Database:\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n\n    def connect(self):\n        return self.connection_string", "tests": "[{'ctx': 'db1 = Database(\"DB1_Connection_String\")\\ndb2 = Database(\"DB2_Connection_String\")', 'assertion': 'db1 is db2'}, {'ctx': 'db1 = Database(\"DB1_Connection_String\")\\ndb2 = Database(\"DB2_Connection_String\")', 'assertion': 'db1.connect() == \"DB1_Connection_String\" and db2.connect() == \"DB2_Connection_String\"'}]", "complexity": 3}
{"task_id": "codeeval-93", "problem": "Create a Python class named `Vehicle` which can be instantiated with a make and model. Create two subclasses named `Car` and `Truck` which inherit from the base class `Vehicle`. The `Car` class should be instantiated with an additional int mileage argument. The `Truck` class should be instantiated with an additional int capacity argument. The base class should implement a method named `describe` which returns a string in the format \"make:model\". The `Car` class should override the `describe` method to return a string in the format \"make:model:mileage\". The `Truck` class should override the `describe` method to return a string in the format \"make:model:capacity\".", "topic": "design pattern", "object": "class", "name": "Vehicle",  "canonical_solution": "class Vehicle:\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n\n    def describe(self):\n        return f\"{self.make}:{self.model}\"\n\nclass Car(Vehicle):\n    def __init__(self, make, model, car_type):\n        super().__init__(make, model)\n        self.car_type = car_type\n\n    def describe(self):\n        return f\"{self.make}:{self.model}:{self.car_type}\"\n\nclass Truck(Vehicle):\n    def __init__(self, make, model, capacity):\n        super().__init__(make, model)\n        self.capacity = capacity\n\n    def describe(self):\n        return f\"{self.make}:{self.model}:{self.capacity}\"", "tests": "[{'ctx': 'vehicle = Vehicle(\"Generic\", \"ModelX\")\\ncar = Car(\"Honda\", \"Civic\", \"Sedan\")\\ntruck = Truck(\"Ford\", \"F-150\", 5)', 'assertion': 'vehicle.describe() == \"Generic:ModelX\" and car.describe() == \"Honda:Civic:Sedan\" and truck.describe() == \"Ford:F-150:5\"'}]", "complexity": 2}
{"task_id": "codeeval-94", "problem": "Create a Python class named `SongPlayer` which can be instantiated with no arguments. The class is composed of capabilities from two other classes named `SongPlayer` and `VolumeControl`. The `SongPlayer` class should implement two methods named `play_song` and `pause_song`. The `play_song` method should take a song_name as an argument and return a string in the format \"Playing {song_name}\". The `pause_song` method should return a string \"Song paused\". The `VolumeControl` class should implement a method named `adjust_volume`. The `adjust_volume` method should take a int level as an argument and return a string in the format \"Adjusting volume to {level}\". Implement methods `play`, `pause` and `set_volume` in the `MusicPlayer` class such that they delegate to the appropriate methods in the SongPlayer and VolumeControl classes.", "topic": "composition", "object": "class", "name": "MusicPlayer", "canonical_solution": "class SongPlayer:\n    def play_song(self, song_name):\n        return f\"Playing {song_name}\"\n\n    def pause_song(self):\n        return \"Song paused\"\n\nclass VolumeControl:\n    def adjust_volume(self, level):\n        return f\"Adjusting volume to {level}\"\n\nclass MusicPlayer:\n    def __init__(self):\n        self.song_player = SongPlayer()\n        self.volume_control = VolumeControl()\n\n    def play(self, song_name):\n        return self.song_player.play_song(song_name)\n\n    def pause(self):\n        return self.song_player.pause_song()\n\n    def set_volume(self, level):\n        return self.volume_control.adjust_volume(level)", "tests": "[{'ctx': 'mp = MusicPlayer()', 'assertion': 'mp.play(\"Bohemian Rhapsody\") == \"Playing Bohemian Rhapsody\"'}, {'ctx': 'mp = MusicPlayer()', 'assertion': 'mp.pause() == \"Song paused\"'}, {'ctx': 'mp = MusicPlayer()', 'assertion': 'mp.set_volume(5) == \"Adjusting volume to 5\"'}]", "complexity": 2}
{"task_id": "codeeval-95", "problem": "Create a Python class named `Car` which can be instantiated with no arguments. The class is composed of capabilities from another class named `Engine` and `Radio`. The `Engine` class should implement two methods named `start` and `stop` that return a string \"Engine started\" and \"Engine stopped\" respectively. The `Radio` class should implement two methods named `turn_on` and `turn_off` that return a string \"Radio turned on\" and \"Radio turned off\" respectively. Implement methods `start_engine`, `stop_engine`, `turn_radio_on` and `turn_radio_off` in the `Car` class such that they delegate to the appropriate methods in the Engine and Radio classes.", "topic": "composition", "object": "class", "name": "Car", "canonical_solution": "class Engine:\n    def start(self):\n        return \"Engine started\"\n\n    def stop(self):\n        return \"Engine stopped\"\n\nclass Radio:\n    def turn_on(self):\n        return \"Radio turned on\"\n\n    def turn_off(self):\n        return \"Radio turned off\"\n\nclass Car:\n    def __init__(self):\n        self.engine = Engine()\n        self.radio = Radio()\n\n    def start_engine(self):\n        return self.engine.start()\n\n    def stop_engine(self):\n        return self.engine.stop()\n\n    def turn_radio_on(self):\n        return self.radio.turn_on()\n\n    def turn_radio_off(self):\n        return self.radio.turn_off()", "tests": "[{'ctx': 'my_car = Car()', 'assertion': 'my_car.start_engine() == \"Engine started\"'}, {'ctx': 'my_car = Car()', 'assertion': 'my_car.turn_radio_on() == \"Radio turned on\"'}, {'ctx': 'my_car = Car()', 'assertion': 'my_car.turn_radio_off() == \"Radio turned off\"'}, {'ctx': 'my_car = Car()', 'assertion': 'my_car.stop_engine() == \"Engine stopped\"'}]", "complexity": 2}
{"task_id": "codeeval-96", "problem": "Create a Python class named `Lamp` which can be instantiated with no arguments. The class is composed of capabilities from another class named `Lightbulb`. The `Lightbulb` class should implement two methods named `turn_on` and `turn_off` that return a string \"Lightbulb on\" and \"Lightbulb off\" respectively. Implement methods `switch_on` and `switch_off` in the `Lamp` class such that they delegate to the appropriate methods in the Lightbulb class.", "topic": "composition", "object": "class", "name": "Lamp", "canonical_solution": "class Lightbulb:\n    def turn_on(self):\n        return \"Lightbulb on\"\n\n    def turn_off(self):\n        return \"Lightbulb off\"\n\nclass Lamp:\n    def __init__(self):\n        self.lightbulb = Lightbulb()\n\n    def switch_on(self):\n        return self.lightbulb.turn_on()\n\n    def switch_off(self):\n        return self.lightbulb.turn_off()", "tests": "[{'ctx': 'my_lamp = Lamp()', 'assertion': 'my_lamp.switch_on() == \"Lightbulb on\"'}, {'ctx': 'my_lamp = Lamp()', 'assertion': 'my_lamp.switch_off() == \"Lightbulb off\"'}]", "complexity": 1}
{"task_id": "codeeval-97", "problem": "Create a metaclass `MethodAdder` that adds a simple method `hello` to any class that uses this metaclass. This method, when called on an instance of the class, will return \"Hello from [ClassName]\" where [ClassName] is the name of the class.","topic": "design pattern", "object": "class", "name": "MethodAdder", "canonical_solution": "class MethodAdder(type):\n    def __new__(cls, name, bases, dct):\n        \n        def hello(self):\n            return f\"Hello from {name}\"\n\n        dct['hello'] = hello\n        return super().__new__(cls, name, bases, dct)", "tests": "[{'ctx': 'class MyClass(metaclass=MethodAdder):\\n    pass\\n\\nobj = MyClass()', 'assertion': 'obj.hello() ==  \"Hello from MyClass\"'}]", "complexity": 3}
{"task_id": "codeeval-98", "problem": "Create a Python metaclass named `Singleton` which can be used to create a class that can only be instantiated once.", "topic": "design pattern", "object": "class", "name": "Singleton", "canonical_solution": "class Singleton(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]", "tests": "[{'ctx': 'class DatabaseConnection(metaclass=Singleton):\\n    def __init__(self):\\n        self.connection = \"Database Connection\"\\n\\ndb1 = DatabaseConnection()\\ndb2 = DatabaseConnection()', 'assertion': 'db1 is db2'}]", "complexity": 3}
{"task_id": "codeeval-99", "problem": "Create a Python mixin class named `JSONSerializableMixin` which can be used to add JSON serialization and deserialization capabilities to a class. Implement method `to_json` which serializes an instance of a class to JSON string and a class method `from_json` which deserializes JSON to an instance.", "topic": "inheritance", "object": "class", "name": "JSONSerializableMixin", "canonical_solution": "import json\n\nclass JSONSerializableMixin:\n    def to_json(self):\n        return json.dumps(self.__dict__)\n\n    @classmethod\n    def from_json(cls, json_str):\n        return cls(**json.loads(json_str))", "tests": "[{'ctx': 'import json\\nclass Person(JSONSerializableMixin):\\n    def __init__(self, name, age):\\n        self.name = name\\n        self.age = age\\n\\nperson = Person(\"Alice\", 30)\\njson_data = person.to_json()', 'assertion': 'json.loads(json_data) == dict(name=\"Alice\", age=30)'}, {'ctx': 'import json\\nclass Person(JSONSerializableMixin):\\n    def __init__(self, name, age):\\n        self.name = name\\n        self.age = age\\n\\nperson = Person.from_json(json.dumps(dict(name=\"Alice\", age=30)))', 'assertion': 'person.name == \"Alice\" and person.age == 30'}]", "complexity": 3}
